<!doctype html>
<html>
<head>
<title>/cluster/home/tgrosser/polly/llvm_git/tools/polly/lib/External/isl/isl_ast_build_expr.c</title>
<style type="text/css">
 body { color:#000000; background-color:#ffffff }
 body { font-family:Helvetica, sans-serif; font-size:10pt }
 h1 { font-size:14pt }
 .code { border-collapse:collapse; width:100%; }
 .code { font-family: "Monospace", monospace; font-size:10pt }
 .code { line-height: 1.2em }
 .comment { color: green; font-style: oblique }
 .keyword { color: blue }
 .string_literal { color: red }
 .directive { color: darkmagenta }
 .expansion { display: none; }
 .macro:hover .expansion { display: block; border: 2px solid #FF0000; padding: 2px; background-color:#FFF0F0; font-weight: normal;   -webkit-border-radius:5px;  -webkit-box-shadow:1px 1px 7px #000; position: absolute; top: -1em; left:10em; z-index: 1 } 
 .macro { color: darkmagenta; background-color:LemonChiffon; position: relative }
 .num { width:2.5em; padding-right:2ex; background-color:#eeeeee }
 .num { text-align:right; font-size:8pt }
 .num { color:#444444 }
 .line { padding-left: 1ex; border-left: 3px solid #ccc }
 .line { white-space: pre }
 .msg { -webkit-box-shadow:1px 1px 7px #000 }
 .msg { -webkit-border-radius:5px }
 .msg { font-family:Helvetica, sans-serif; font-size:8pt }
 .msg { float:left }
 .msg { padding:0.25em 1ex 0.25em 1ex }
 .msg { margin-top:10px; margin-bottom:10px }
 .msg { font-weight:bold }
 .msg { max-width:60em; word-wrap: break-word; white-space: pre-wrap }
 .msgT { padding:0x; spacing:0x }
 .msgEvent { background-color:#fff8b4; color:#000000 }
 .msgControl { background-color:#bbbbbb; color:#000000 }
 .mrange { background-color:#dfddf3 }
 .mrange { border-bottom:1px solid #6F9DBE }
 .PathIndex { font-weight: bold; padding:0px 5px; margin-right:5px; }
 .PathIndex { -webkit-border-radius:8px }
 .PathIndexEvent { background-color:#bfba87 }
 .PathIndexControl { background-color:#8c8c8c }
 .PathNav a { text-decoration:none; font-size: larger }
 .CodeInsertionHint { font-weight: bold; background-color: #10dd10 }
 .CodeRemovalHint { background-color:#de1010 }
 .CodeRemovalHint { border-bottom:1px solid #6F9DBE }
 table.simpletable {
   padding: 5px;
   font-size:12pt;
   margin:20px;
   border-collapse: collapse; border-spacing: 0px;
 }
 td.rowname {
   text-align:right; font-weight:bold; color:#444444;
   padding-right:2ex; }
</style>
</head>
<body>
<!-- BUGDESC Potential leak of an object -->

<!-- BUGTYPE Leak -->

<!-- BUGCATEGORY Memory (Core Foundation/Objective-C) -->

<!-- BUGFILE /cluster/home/tgrosser/polly/llvm_git/tools/polly/lib/External/isl/isl_ast_build_expr.c -->

<!-- FILENAME isl_ast_build_expr.c -->

<!-- FUNCTIONNAME extract_mod -->

<!-- ISSUEHASHCONTENTOFLINEINCONTEXT a1b635993dae1cc1e1547aad408a8218 -->

<!-- BUGLINE 575 -->

<!-- BUGCOLUMN 2 -->

<!-- BUGPATHLENGTH 7 -->

<!-- BUGMETAEND -->
<!-- REPORTHEADER -->
<h3>Bug Summary</h3>
<table class="simpletable">
<tr><td class="rowname">File:</td><td>External/isl/isl_ast_build_expr.c</td></tr>
<tr><td class="rowname">Location:</td><td><a href="#EndPath">line 575, column 2</a></td></tr>
<tr><td class="rowname">Description:</td><td>Potential leak of an object</td></tr>
<tr><td></td><td>Code is compiled to use reference counts</td></tr>
</table>
<!-- REPORTSUMMARYEXTRA -->
<h3>Annotated Source Code</h3>
<table class="code">
<tr><td class="num" id="LN1">1</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr><td class="num" id="LN2">2</td><td class="line"> <span class='comment'>* Copyright 2012-2014 Ecole Normale Superieure</span></td></tr>
<tr><td class="num" id="LN3">3</td><td class="line"> <span class='comment'>* Copyright 2014      INRIA Rocquencourt</span></td></tr>
<tr><td class="num" id="LN4">4</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN5">5</td><td class="line"> <span class='comment'>* Use of this software is governed by the MIT license</span></td></tr>
<tr><td class="num" id="LN6">6</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN7">7</td><td class="line"> <span class='comment'>* Written by Sven Verdoolaege,</span></td></tr>
<tr><td class="num" id="LN8">8</td><td class="line"> <span class='comment'>* Ecole Normale Superieure, 45 rue dâ€™Ulm, 75230 Paris, France</span></td></tr>
<tr><td class="num" id="LN9">9</td><td class="line"> <span class='comment'>* and Inria Paris - Rocquencourt, Domaine de Voluceau - Rocquencourt,</span></td></tr>
<tr><td class="num" id="LN10">10</td><td class="line"> <span class='comment'>* B.P. 105 - 78153 Le Chesnay, France</span></td></tr>
<tr><td class="num" id="LN11">11</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN12">12</td><td class="line"> </td></tr>
<tr><td class="num" id="LN13">13</td><td class="line"><span class='directive'>#include &lt;isl/constraint.h&gt;</span></td></tr>
<tr><td class="num" id="LN14">14</td><td class="line"><span class='directive'>#include &lt;isl/ilp.h&gt;</span></td></tr>
<tr><td class="num" id="LN15">15</td><td class="line"><span class='directive'>#include &lt;isl_ast_build_expr.h&gt;</span></td></tr>
<tr><td class="num" id="LN16">16</td><td class="line"><span class='directive'>#include &lt;isl_ast_private.h&gt;</span></td></tr>
<tr><td class="num" id="LN17">17</td><td class="line"><span class='directive'>#include &lt;isl_ast_build_private.h&gt;</span></td></tr>
<tr><td class="num" id="LN18">18</td><td class="line"><span class='directive'>#include &lt;isl_sort.h&gt;</span></td></tr>
<tr><td class="num" id="LN19">19</td><td class="line"> </td></tr>
<tr><td class="num" id="LN20">20</td><td class="line"><span class='comment'>/* Compute the "opposite" of the (numerator of the) argument of a div</span></td></tr>
<tr><td class="num" id="LN21">21</td><td class="line"> <span class='comment'>* with denominator "d".</span></td></tr>
<tr><td class="num" id="LN22">22</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN23">23</td><td class="line"> <span class='comment'>* In particular, compute</span></td></tr>
<tr><td class="num" id="LN24">24</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN25">25</td><td class="line"> <span class='comment'>*	-aff + (d - 1)</span></td></tr>
<tr><td class="num" id="LN26">26</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN27">27</td><td class="line"><span class='keyword'>static</span> <span class='macro'>__isl_give<span class='expansion'>__attribute__((cf_returns_retained))</span></span> isl_aff *oppose_div_arg(<span class='macro'>__isl_take<span class='expansion'>__attribute__((cf_consumed))</span></span> isl_aff *aff,</td></tr>
<tr><td class="num" id="LN28">28</td><td class="line">	<span class='macro'>__isl_take<span class='expansion'>__attribute__((cf_consumed))</span></span> isl_val *d)</td></tr>
<tr><td class="num" id="LN29">29</td><td class="line">{</td></tr>
<tr><td class="num" id="LN30">30</td><td class="line">	aff = isl_aff_neg(aff);</td></tr>
<tr><td class="num" id="LN31">31</td><td class="line">	aff = isl_aff_add_constant_val(aff, d);</td></tr>
<tr><td class="num" id="LN32">32</td><td class="line">	aff = isl_aff_add_constant_si(aff, -1);</td></tr>
<tr><td class="num" id="LN33">33</td><td class="line"> </td></tr>
<tr><td class="num" id="LN34">34</td><td class="line">	<span class='keyword'>return</span> aff;</td></tr>
<tr><td class="num" id="LN35">35</td><td class="line">}</td></tr>
<tr><td class="num" id="LN36">36</td><td class="line"> </td></tr>
<tr><td class="num" id="LN37">37</td><td class="line"><span class='comment'>/* Internal data structure used inside isl_ast_expr_add_term.</span></td></tr>
<tr><td class="num" id="LN38">38</td><td class="line"> <span class='comment'>* The domain of "build" is used to simplify the expressions.</span></td></tr>
<tr><td class="num" id="LN39">39</td><td class="line"> <span class='comment'>* "build" needs to be set by the caller of isl_ast_expr_add_term.</span></td></tr>
<tr><td class="num" id="LN40">40</td><td class="line"> <span class='comment'>* "cst" is the constant term of the expression in which the added term</span></td></tr>
<tr><td class="num" id="LN41">41</td><td class="line"> <span class='comment'>* appears.  It may be modified by isl_ast_expr_add_term.</span></td></tr>
<tr><td class="num" id="LN42">42</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN43">43</td><td class="line"> <span class='comment'>* "v" is the coefficient of the term that is being constructed and</span></td></tr>
<tr><td class="num" id="LN44">44</td><td class="line"> <span class='comment'>* is set internally by isl_ast_expr_add_term.</span></td></tr>
<tr><td class="num" id="LN45">45</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN46">46</td><td class="line"><span class='keyword'>struct</span> isl_ast_add_term_data {</td></tr>
<tr><td class="num" id="LN47">47</td><td class="line">	isl_ast_build *build;</td></tr>
<tr><td class="num" id="LN48">48</td><td class="line">	isl_val *cst;</td></tr>
<tr><td class="num" id="LN49">49</td><td class="line">	isl_val *v;</td></tr>
<tr><td class="num" id="LN50">50</td><td class="line">};</td></tr>
<tr><td class="num" id="LN51">51</td><td class="line"> </td></tr>
<tr><td class="num" id="LN52">52</td><td class="line"><span class='comment'>/* Given the numerator "aff" of the argument of an integer division</span></td></tr>
<tr><td class="num" id="LN53">53</td><td class="line"> <span class='comment'>* with denominator "d", check if it can be made non-negative over</span></td></tr>
<tr><td class="num" id="LN54">54</td><td class="line"> <span class='comment'>* data-&gt;build-&gt;domain by stealing part of the constant term of</span></td></tr>
<tr><td class="num" id="LN55">55</td><td class="line"> <span class='comment'>* the expression in which the integer division appears.</span></td></tr>
<tr><td class="num" id="LN56">56</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN57">57</td><td class="line"> <span class='comment'>* In particular, the outer expression is of the form</span></td></tr>
<tr><td class="num" id="LN58">58</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN59">59</td><td class="line"> <span class='comment'>*	v * floor(aff/d) + cst</span></td></tr>
<tr><td class="num" id="LN60">60</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN61">61</td><td class="line"> <span class='comment'>* We already know that "aff" itself may attain negative values.</span></td></tr>
<tr><td class="num" id="LN62">62</td><td class="line"> <span class='comment'>* Here we check if aff + d*floor(cst/v) is non-negative, such</span></td></tr>
<tr><td class="num" id="LN63">63</td><td class="line"> <span class='comment'>* that we could rewrite the expression to</span></td></tr>
<tr><td class="num" id="LN64">64</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN65">65</td><td class="line"> <span class='comment'>*	v * floor((aff + d*floor(cst/v))/d) + cst - v*floor(cst/v)</span></td></tr>
<tr><td class="num" id="LN66">66</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN67">67</td><td class="line"> <span class='comment'>* Note that aff + d*floor(cst/v) can only possibly be non-negative</span></td></tr>
<tr><td class="num" id="LN68">68</td><td class="line"> <span class='comment'>* if data-&gt;cst and data-&gt;v have the same sign.</span></td></tr>
<tr><td class="num" id="LN69">69</td><td class="line"> <span class='comment'>* Similarly, if floor(cst/v) is zero, then there is no point in</span></td></tr>
<tr><td class="num" id="LN70">70</td><td class="line"> <span class='comment'>* checking again.</span></td></tr>
<tr><td class="num" id="LN71">71</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN72">72</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>int</span> is_non_neg_after_stealing(__isl_keep isl_aff *aff,</td></tr>
<tr><td class="num" id="LN73">73</td><td class="line">	__isl_keep isl_val *d, <span class='keyword'>struct</span> isl_ast_add_term_data *data)</td></tr>
<tr><td class="num" id="LN74">74</td><td class="line">{</td></tr>
<tr><td class="num" id="LN75">75</td><td class="line">	isl_aff *shifted;</td></tr>
<tr><td class="num" id="LN76">76</td><td class="line">	isl_val *shift;</td></tr>
<tr><td class="num" id="LN77">77</td><td class="line">	<span class='keyword'>int</span> is_zero;</td></tr>
<tr><td class="num" id="LN78">78</td><td class="line">	<span class='keyword'>int</span> non_neg;</td></tr>
<tr><td class="num" id="LN79">79</td><td class="line"> </td></tr>
<tr><td class="num" id="LN80">80</td><td class="line">	<span class='keyword'>if</span> (isl_val_sgn(data-&gt;cst) != isl_val_sgn(data-&gt;v))</td></tr>
<tr><td class="num" id="LN81">81</td><td class="line">		<span class='keyword'>return</span> 0;</td></tr>
<tr><td class="num" id="LN82">82</td><td class="line"> </td></tr>
<tr><td class="num" id="LN83">83</td><td class="line">	shift = isl_val_div(isl_val_copy(data-&gt;cst), isl_val_copy(data-&gt;v));</td></tr>
<tr><td class="num" id="LN84">84</td><td class="line">	shift = isl_val_floor(shift);</td></tr>
<tr><td class="num" id="LN85">85</td><td class="line">	is_zero = isl_val_is_zero(shift);</td></tr>
<tr><td class="num" id="LN86">86</td><td class="line">	<span class='keyword'>if</span> (is_zero &lt; 0 || is_zero) {</td></tr>
<tr><td class="num" id="LN87">87</td><td class="line">		isl_val_free(shift);</td></tr>
<tr><td class="num" id="LN88">88</td><td class="line">		<span class='keyword'>return</span> is_zero &lt; 0 ? -1 : 0;</td></tr>
<tr><td class="num" id="LN89">89</td><td class="line">	}</td></tr>
<tr><td class="num" id="LN90">90</td><td class="line">	shift = isl_val_mul(shift, isl_val_copy(d));</td></tr>
<tr><td class="num" id="LN91">91</td><td class="line">	shifted = isl_aff_copy(aff);</td></tr>
<tr><td class="num" id="LN92">92</td><td class="line">	shifted = isl_aff_add_constant_val(shifted, shift);</td></tr>
<tr><td class="num" id="LN93">93</td><td class="line">	non_neg = isl_ast_build_aff_is_nonneg(data-&gt;build, shifted);</td></tr>
<tr><td class="num" id="LN94">94</td><td class="line">	isl_aff_free(shifted);</td></tr>
<tr><td class="num" id="LN95">95</td><td class="line"> </td></tr>
<tr><td class="num" id="LN96">96</td><td class="line">	<span class='keyword'>return</span> non_neg;</td></tr>
<tr><td class="num" id="LN97">97</td><td class="line">}</td></tr>
<tr><td class="num" id="LN98">98</td><td class="line"> </td></tr>
<tr><td class="num" id="LN99">99</td><td class="line"><span class='comment'>/* Given the numerator "aff' of the argument of an integer division</span></td></tr>
<tr><td class="num" id="LN100">100</td><td class="line"> <span class='comment'>* with denominator "d", steal part of the constant term of</span></td></tr>
<tr><td class="num" id="LN101">101</td><td class="line"> <span class='comment'>* the expression in which the integer division appears to make it</span></td></tr>
<tr><td class="num" id="LN102">102</td><td class="line"> <span class='comment'>* non-negative over data-&gt;build-&gt;domain.</span></td></tr>
<tr><td class="num" id="LN103">103</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN104">104</td><td class="line"> <span class='comment'>* In particular, the outer expression is of the form</span></td></tr>
<tr><td class="num" id="LN105">105</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN106">106</td><td class="line"> <span class='comment'>*	v * floor(aff/d) + cst</span></td></tr>
<tr><td class="num" id="LN107">107</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN108">108</td><td class="line"> <span class='comment'>* We know that "aff" itself may attain negative values,</span></td></tr>
<tr><td class="num" id="LN109">109</td><td class="line"> <span class='comment'>* but that aff + d*floor(cst/v) is non-negative.</span></td></tr>
<tr><td class="num" id="LN110">110</td><td class="line"> <span class='comment'>* Find the minimal positive value that we need to add to "aff"</span></td></tr>
<tr><td class="num" id="LN111">111</td><td class="line"> <span class='comment'>* to make it positive and adjust data-&gt;cst accordingly.</span></td></tr>
<tr><td class="num" id="LN112">112</td><td class="line"> <span class='comment'>* That is, compute the minimal value "m" of "aff" over</span></td></tr>
<tr><td class="num" id="LN113">113</td><td class="line"> <span class='comment'>* data-&gt;build-&gt;domain and take</span></td></tr>
<tr><td class="num" id="LN114">114</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN115">115</td><td class="line"> <span class='comment'>*	s = ceil(m/d)</span></td></tr>
<tr><td class="num" id="LN116">116</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN117">117</td><td class="line"> <span class='comment'>* such that</span></td></tr>
<tr><td class="num" id="LN118">118</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN119">119</td><td class="line"> <span class='comment'>*	aff + d * s &gt;= 0</span></td></tr>
<tr><td class="num" id="LN120">120</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN121">121</td><td class="line"> <span class='comment'>* and rewrite the expression to</span></td></tr>
<tr><td class="num" id="LN122">122</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN123">123</td><td class="line"> <span class='comment'>*	v * floor((aff + s*d)/d) + (cst - v*s)</span></td></tr>
<tr><td class="num" id="LN124">124</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN125">125</td><td class="line"><span class='keyword'>static</span> <span class='macro'>__isl_give<span class='expansion'>__attribute__((cf_returns_retained))</span></span> isl_aff *steal_from_cst(<span class='macro'>__isl_take<span class='expansion'>__attribute__((cf_consumed))</span></span> isl_aff *aff,</td></tr>
<tr><td class="num" id="LN126">126</td><td class="line">	__isl_keep isl_val *d, <span class='keyword'>struct</span> isl_ast_add_term_data *data)</td></tr>
<tr><td class="num" id="LN127">127</td><td class="line">{</td></tr>
<tr><td class="num" id="LN128">128</td><td class="line">	isl_set *domain;</td></tr>
<tr><td class="num" id="LN129">129</td><td class="line">	isl_val *shift, *t;</td></tr>
<tr><td class="num" id="LN130">130</td><td class="line"> </td></tr>
<tr><td class="num" id="LN131">131</td><td class="line">	domain = isl_ast_build_get_domain(data-&gt;build);</td></tr>
<tr><td class="num" id="LN132">132</td><td class="line">	shift = isl_set_min_val(domain, aff);</td></tr>
<tr><td class="num" id="LN133">133</td><td class="line">	isl_set_free(domain);</td></tr>
<tr><td class="num" id="LN134">134</td><td class="line"> </td></tr>
<tr><td class="num" id="LN135">135</td><td class="line">	shift = isl_val_neg(shift);</td></tr>
<tr><td class="num" id="LN136">136</td><td class="line">	shift = isl_val_div(shift, isl_val_copy(d));</td></tr>
<tr><td class="num" id="LN137">137</td><td class="line">	shift = isl_val_ceil(shift);</td></tr>
<tr><td class="num" id="LN138">138</td><td class="line"> </td></tr>
<tr><td class="num" id="LN139">139</td><td class="line">	t = isl_val_copy(shift);</td></tr>
<tr><td class="num" id="LN140">140</td><td class="line">	t = isl_val_mul(t, isl_val_copy(data-&gt;v));</td></tr>
<tr><td class="num" id="LN141">141</td><td class="line">	data-&gt;cst = isl_val_sub(data-&gt;cst, t);</td></tr>
<tr><td class="num" id="LN142">142</td><td class="line"> </td></tr>
<tr><td class="num" id="LN143">143</td><td class="line">	shift = isl_val_mul(shift, isl_val_copy(d));</td></tr>
<tr><td class="num" id="LN144">144</td><td class="line">	<span class='keyword'>return</span> isl_aff_add_constant_val(aff, shift);</td></tr>
<tr><td class="num" id="LN145">145</td><td class="line">}</td></tr>
<tr><td class="num" id="LN146">146</td><td class="line"> </td></tr>
<tr><td class="num" id="LN147">147</td><td class="line"><span class='comment'>/* Create an isl_ast_expr evaluating the div at position "pos" in "ls".</span></td></tr>
<tr><td class="num" id="LN148">148</td><td class="line"> <span class='comment'>* The result is simplified in terms of data-&gt;build-&gt;domain.</span></td></tr>
<tr><td class="num" id="LN149">149</td><td class="line"> <span class='comment'>* This function may change (the sign of) data-&gt;v.</span></td></tr>
<tr><td class="num" id="LN150">150</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN151">151</td><td class="line"> <span class='comment'>* "ls" is known to be non-NULL.</span></td></tr>
<tr><td class="num" id="LN152">152</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN153">153</td><td class="line"> <span class='comment'>* Let the div be of the form floor(e/d).</span></td></tr>
<tr><td class="num" id="LN154">154</td><td class="line"> <span class='comment'>* If the ast_build_prefer_pdiv option is set then we check if "e"</span></td></tr>
<tr><td class="num" id="LN155">155</td><td class="line"> <span class='comment'>* is non-negative, so that we can generate</span></td></tr>
<tr><td class="num" id="LN156">156</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN157">157</td><td class="line"> <span class='comment'>*	(pdiv_q, expr(e), expr(d))</span></td></tr>
<tr><td class="num" id="LN158">158</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN159">159</td><td class="line"> <span class='comment'>* instead of</span></td></tr>
<tr><td class="num" id="LN160">160</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN161">161</td><td class="line"> <span class='comment'>*	(fdiv_q, expr(e), expr(d))</span></td></tr>
<tr><td class="num" id="LN162">162</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN163">163</td><td class="line"> <span class='comment'>* If the ast_build_prefer_pdiv option is set and</span></td></tr>
<tr><td class="num" id="LN164">164</td><td class="line"> <span class='comment'>* if "e" is not non-negative, then we check if "-e + d - 1" is non-negative.</span></td></tr>
<tr><td class="num" id="LN165">165</td><td class="line"> <span class='comment'>* If so, we can rewrite</span></td></tr>
<tr><td class="num" id="LN166">166</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN167">167</td><td class="line"> <span class='comment'>*	floor(e/d) = -ceil(-e/d) = -floor((-e + d - 1)/d)</span></td></tr>
<tr><td class="num" id="LN168">168</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN169">169</td><td class="line"> <span class='comment'>* and still use pdiv_q, while changing the sign of data-&gt;v.</span></td></tr>
<tr><td class="num" id="LN170">170</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN171">171</td><td class="line"> <span class='comment'>* Otherwise, we check if</span></td></tr>
<tr><td class="num" id="LN172">172</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN173">173</td><td class="line"> <span class='comment'>*	e + d*floor(cst/v)</span></td></tr>
<tr><td class="num" id="LN174">174</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN175">175</td><td class="line"> <span class='comment'>* is non-negative and if so, replace floor(e/d) by</span></td></tr>
<tr><td class="num" id="LN176">176</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN177">177</td><td class="line"> <span class='comment'>*	floor((e + s*d)/d) - s</span></td></tr>
<tr><td class="num" id="LN178">178</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN179">179</td><td class="line"> <span class='comment'>* with s the minimal shift that makes the argument non-negative.</span></td></tr>
<tr><td class="num" id="LN180">180</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN181">181</td><td class="line"><span class='keyword'>static</span> <span class='macro'>__isl_give<span class='expansion'>__attribute__((cf_returns_retained))</span></span> isl_ast_expr *var_div(<span class='keyword'>struct</span> isl_ast_add_term_data *data,</td></tr>
<tr><td class="num" id="LN182">182</td><td class="line">	__isl_keep isl_local_space *ls, <span class='keyword'>int</span> pos)</td></tr>
<tr><td class="num" id="LN183">183</td><td class="line">{</td></tr>
<tr><td class="num" id="LN184">184</td><td class="line">	isl_ctx *ctx = isl_local_space_get_ctx(ls);</td></tr>
<tr><td class="num" id="LN185">185</td><td class="line">	isl_aff *aff;</td></tr>
<tr><td class="num" id="LN186">186</td><td class="line">	isl_ast_expr *num, *den;</td></tr>
<tr><td class="num" id="LN187">187</td><td class="line">	isl_val *d;</td></tr>
<tr><td class="num" id="LN188">188</td><td class="line">	<span class='keyword'>enum</span> isl_ast_op_type type;</td></tr>
<tr><td class="num" id="LN189">189</td><td class="line"> </td></tr>
<tr><td class="num" id="LN190">190</td><td class="line">	aff = isl_local_space_get_div(ls, pos);</td></tr>
<tr><td class="num" id="LN191">191</td><td class="line">	d = isl_aff_get_denominator_val(aff);</td></tr>
<tr><td class="num" id="LN192">192</td><td class="line">	aff = isl_aff_scale_val(aff, isl_val_copy(d));</td></tr>
<tr><td class="num" id="LN193">193</td><td class="line">	den = isl_ast_expr_from_val(isl_val_copy(d));</td></tr>
<tr><td class="num" id="LN194">194</td><td class="line"> </td></tr>
<tr><td class="num" id="LN195">195</td><td class="line">	type = isl_ast_op_fdiv_q;</td></tr>
<tr><td class="num" id="LN196">196</td><td class="line">	<span class='keyword'>if</span> (isl_options_get_ast_build_prefer_pdiv(ctx)) {</td></tr>
<tr><td class="num" id="LN197">197</td><td class="line">		<span class='keyword'>int</span> non_neg = isl_ast_build_aff_is_nonneg(data-&gt;build, aff);</td></tr>
<tr><td class="num" id="LN198">198</td><td class="line">		<span class='keyword'>if</span> (non_neg &gt;= 0 &amp;&amp; !non_neg) {</td></tr>
<tr><td class="num" id="LN199">199</td><td class="line">			isl_aff *opp = oppose_div_arg(isl_aff_copy(aff),</td></tr>
<tr><td class="num" id="LN200">200</td><td class="line">							isl_val_copy(d));</td></tr>
<tr><td class="num" id="LN201">201</td><td class="line">			non_neg = isl_ast_build_aff_is_nonneg(data-&gt;build, opp);</td></tr>
<tr><td class="num" id="LN202">202</td><td class="line">			<span class='keyword'>if</span> (non_neg &gt;= 0 &amp;&amp; non_neg) {</td></tr>
<tr><td class="num" id="LN203">203</td><td class="line">				data-&gt;v = isl_val_neg(data-&gt;v);</td></tr>
<tr><td class="num" id="LN204">204</td><td class="line">				isl_aff_free(aff);</td></tr>
<tr><td class="num" id="LN205">205</td><td class="line">				aff = opp;</td></tr>
<tr><td class="num" id="LN206">206</td><td class="line">			} <span class='keyword'>else</span></td></tr>
<tr><td class="num" id="LN207">207</td><td class="line">				isl_aff_free(opp);</td></tr>
<tr><td class="num" id="LN208">208</td><td class="line">		}</td></tr>
<tr><td class="num" id="LN209">209</td><td class="line">		<span class='keyword'>if</span> (non_neg &gt;= 0 &amp;&amp; !non_neg) {</td></tr>
<tr><td class="num" id="LN210">210</td><td class="line">			non_neg = is_non_neg_after_stealing(aff, d, data);</td></tr>
<tr><td class="num" id="LN211">211</td><td class="line">			<span class='keyword'>if</span> (non_neg &gt;= 0 &amp;&amp; non_neg)</td></tr>
<tr><td class="num" id="LN212">212</td><td class="line">				aff = steal_from_cst(aff, d, data);</td></tr>
<tr><td class="num" id="LN213">213</td><td class="line">		}</td></tr>
<tr><td class="num" id="LN214">214</td><td class="line">		<span class='keyword'>if</span> (non_neg &lt; 0)</td></tr>
<tr><td class="num" id="LN215">215</td><td class="line">			aff = isl_aff_free(aff);</td></tr>
<tr><td class="num" id="LN216">216</td><td class="line">		<span class='keyword'>else</span> <span class='keyword'>if</span> (non_neg)</td></tr>
<tr><td class="num" id="LN217">217</td><td class="line">			type = isl_ast_op_pdiv_q;</td></tr>
<tr><td class="num" id="LN218">218</td><td class="line">	}</td></tr>
<tr><td class="num" id="LN219">219</td><td class="line"> </td></tr>
<tr><td class="num" id="LN220">220</td><td class="line">	isl_val_free(d);</td></tr>
<tr><td class="num" id="LN221">221</td><td class="line">	num = isl_ast_expr_from_aff(aff, data-&gt;build);</td></tr>
<tr><td class="num" id="LN222">222</td><td class="line">	<span class='keyword'>return</span> isl_ast_expr_alloc_binary(type, num, den);</td></tr>
<tr><td class="num" id="LN223">223</td><td class="line">}</td></tr>
<tr><td class="num" id="LN224">224</td><td class="line"> </td></tr>
<tr><td class="num" id="LN225">225</td><td class="line"><span class='comment'>/* Create an isl_ast_expr evaluating the specified dimension of "ls".</span></td></tr>
<tr><td class="num" id="LN226">226</td><td class="line"> <span class='comment'>* The result is simplified in terms of data-&gt;build-&gt;domain.</span></td></tr>
<tr><td class="num" id="LN227">227</td><td class="line"> <span class='comment'>* This function may change (the sign of) data-&gt;v.</span></td></tr>
<tr><td class="num" id="LN228">228</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN229">229</td><td class="line"> <span class='comment'>* The isl_ast_expr is constructed based on the type of the dimension.</span></td></tr>
<tr><td class="num" id="LN230">230</td><td class="line"> <span class='comment'>* - divs are constructed by var_div</span></td></tr>
<tr><td class="num" id="LN231">231</td><td class="line"> <span class='comment'>* - set variables are constructed from the iterator isl_ids in data-&gt;build</span></td></tr>
<tr><td class="num" id="LN232">232</td><td class="line"> <span class='comment'>* - parameters are constructed from the isl_ids in "ls"</span></td></tr>
<tr><td class="num" id="LN233">233</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN234">234</td><td class="line"><span class='keyword'>static</span> <span class='macro'>__isl_give<span class='expansion'>__attribute__((cf_returns_retained))</span></span> isl_ast_expr *var(<span class='keyword'>struct</span> isl_ast_add_term_data *data,</td></tr>
<tr><td class="num" id="LN235">235</td><td class="line">	__isl_keep isl_local_space *ls, <span class='keyword'>enum</span> isl_dim_type type, <span class='keyword'>int</span> pos)</td></tr>
<tr><td class="num" id="LN236">236</td><td class="line">{</td></tr>
<tr><td class="num" id="LN237">237</td><td class="line">	isl_ctx *ctx = isl_local_space_get_ctx(ls);</td></tr>
<tr><td class="num" id="LN238">238</td><td class="line">	isl_id *id;</td></tr>
<tr><td class="num" id="LN239">239</td><td class="line"> </td></tr>
<tr><td class="num" id="LN240">240</td><td class="line">	<span class='keyword'>if</span> (type == isl_dim_div)</td></tr>
<tr><td class="num" id="LN241">241</td><td class="line">		<span class='keyword'>return</span> var_div(data, ls, pos);</td></tr>
<tr><td class="num" id="LN242">242</td><td class="line"> </td></tr>
<tr><td class="num" id="LN243">243</td><td class="line">	<span class='keyword'>if</span> (type == isl_dim_set) {</td></tr>
<tr><td class="num" id="LN244">244</td><td class="line">		id = isl_ast_build_get_iterator_id(data-&gt;build, pos);</td></tr>
<tr><td class="num" id="LN245">245</td><td class="line">		<span class='keyword'>return</span> isl_ast_expr_from_id(id);</td></tr>
<tr><td class="num" id="LN246">246</td><td class="line">	}</td></tr>
<tr><td class="num" id="LN247">247</td><td class="line"> </td></tr>
<tr><td class="num" id="LN248">248</td><td class="line">	<span class='keyword'>if</span> (!isl_local_space_has_dim_id(ls, type, pos))</td></tr>
<tr><td class="num" id="LN249">249</td><td class="line">		<span class='macro'>isl_die(ctx, isl_error_internal, <span class='string_literal'>"unnamed dimension"</span>,<span class='expansion'>do { isl_handle_error(ctx, isl_error_internal, "unnamed dimension"<br>, "/cluster/home/tgrosser/polly/llvm_git/tools/polly/lib/External/isl/isl_ast_build_expr.c"<br>, 250); return ((void*)0); } while (0)</span></span></td></tr>
<tr><td class="num" id="LN250">250</td><td class="line">			<span class='keyword'><span class='macro'>return</span> NULL)<span class='expansion'>do { isl_handle_error(ctx, isl_error_internal, "unnamed dimension"<br>, "/cluster/home/tgrosser/polly/llvm_git/tools/polly/lib/External/isl/isl_ast_build_expr.c"<br>, 250); return ((void*)0); } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN251">251</td><td class="line">	id = isl_local_space_get_dim_id(ls, type, pos);</td></tr>
<tr><td class="num" id="LN252">252</td><td class="line">	<span class='keyword'>return</span> isl_ast_expr_from_id(id);</td></tr>
<tr><td class="num" id="LN253">253</td><td class="line">}</td></tr>
<tr><td class="num" id="LN254">254</td><td class="line"> </td></tr>
<tr><td class="num" id="LN255">255</td><td class="line"><span class='comment'>/* Does "expr" represent the zero integer?</span></td></tr>
<tr><td class="num" id="LN256">256</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN257">257</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>int</span> ast_expr_is_zero(__isl_keep isl_ast_expr *expr)</td></tr>
<tr><td class="num" id="LN258">258</td><td class="line">{</td></tr>
<tr><td class="num" id="LN259">259</td><td class="line">	<span class='keyword'>if</span> (!expr)</td></tr>
<tr><td class="num" id="LN260">260</td><td class="line">		<span class='keyword'>return</span> -1;</td></tr>
<tr><td class="num" id="LN261">261</td><td class="line">	<span class='keyword'>if</span> (expr-&gt;type != isl_ast_expr_int)</td></tr>
<tr><td class="num" id="LN262">262</td><td class="line">		<span class='keyword'>return</span> 0;</td></tr>
<tr><td class="num" id="LN263">263</td><td class="line">	<span class='keyword'>return</span> isl_val_is_zero(expr-&gt;u.v);</td></tr>
<tr><td class="num" id="LN264">264</td><td class="line">}</td></tr>
<tr><td class="num" id="LN265">265</td><td class="line"> </td></tr>
<tr><td class="num" id="LN266">266</td><td class="line"><span class='comment'>/* Create an expression representing the sum of "expr1" and "expr2",</span></td></tr>
<tr><td class="num" id="LN267">267</td><td class="line"> <span class='comment'>* provided neither of the two expressions is identically zero.</span></td></tr>
<tr><td class="num" id="LN268">268</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN269">269</td><td class="line"><span class='keyword'>static</span> <span class='macro'>__isl_give<span class='expansion'>__attribute__((cf_returns_retained))</span></span> isl_ast_expr *ast_expr_add(<span class='macro'>__isl_take<span class='expansion'>__attribute__((cf_consumed))</span></span> isl_ast_expr *expr1,</td></tr>
<tr><td class="num" id="LN270">270</td><td class="line">	<span class='macro'>__isl_take<span class='expansion'>__attribute__((cf_consumed))</span></span> isl_ast_expr *expr2)</td></tr>
<tr><td class="num" id="LN271">271</td><td class="line">{</td></tr>
<tr><td class="num" id="LN272">272</td><td class="line">	<span class='keyword'>if</span> (!expr1 || !expr2)</td></tr>
<tr><td class="num" id="LN273">273</td><td class="line">		<span class='keyword'>goto</span> error;</td></tr>
<tr><td class="num" id="LN274">274</td><td class="line"> </td></tr>
<tr><td class="num" id="LN275">275</td><td class="line">	<span class='keyword'>if</span> (ast_expr_is_zero(expr1)) {</td></tr>
<tr><td class="num" id="LN276">276</td><td class="line">		isl_ast_expr_free(expr1);</td></tr>
<tr><td class="num" id="LN277">277</td><td class="line">		<span class='keyword'>return</span> expr2;</td></tr>
<tr><td class="num" id="LN278">278</td><td class="line">	}</td></tr>
<tr><td class="num" id="LN279">279</td><td class="line"> </td></tr>
<tr><td class="num" id="LN280">280</td><td class="line">	<span class='keyword'>if</span> (ast_expr_is_zero(expr2)) {</td></tr>
<tr><td class="num" id="LN281">281</td><td class="line">		isl_ast_expr_free(expr2);</td></tr>
<tr><td class="num" id="LN282">282</td><td class="line">		<span class='keyword'>return</span> expr1;</td></tr>
<tr><td class="num" id="LN283">283</td><td class="line">	}</td></tr>
<tr><td class="num" id="LN284">284</td><td class="line"> </td></tr>
<tr><td class="num" id="LN285">285</td><td class="line">	<span class='keyword'>return</span> isl_ast_expr_add(expr1, expr2);</td></tr>
<tr><td class="num" id="LN286">286</td><td class="line">error:</td></tr>
<tr><td class="num" id="LN287">287</td><td class="line">	isl_ast_expr_free(expr1);</td></tr>
<tr><td class="num" id="LN288">288</td><td class="line">	isl_ast_expr_free(expr2);</td></tr>
<tr><td class="num" id="LN289">289</td><td class="line">	<span class='keyword'>return</span> <span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;</td></tr>
<tr><td class="num" id="LN290">290</td><td class="line">}</td></tr>
<tr><td class="num" id="LN291">291</td><td class="line"> </td></tr>
<tr><td class="num" id="LN292">292</td><td class="line"><span class='comment'>/* Subtract expr2 from expr1.</span></td></tr>
<tr><td class="num" id="LN293">293</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN294">294</td><td class="line"> <span class='comment'>* If expr2 is zero, we simply return expr1.</span></td></tr>
<tr><td class="num" id="LN295">295</td><td class="line"> <span class='comment'>* If expr1 is zero, we return</span></td></tr>
<tr><td class="num" id="LN296">296</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN297">297</td><td class="line"> <span class='comment'>*	(isl_ast_op_minus, expr2)</span></td></tr>
<tr><td class="num" id="LN298">298</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN299">299</td><td class="line"> <span class='comment'>* Otherwise, we return</span></td></tr>
<tr><td class="num" id="LN300">300</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN301">301</td><td class="line"> <span class='comment'>*	(isl_ast_op_sub, expr1, expr2)</span></td></tr>
<tr><td class="num" id="LN302">302</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN303">303</td><td class="line"><span class='keyword'>static</span> <span class='macro'>__isl_give<span class='expansion'>__attribute__((cf_returns_retained))</span></span> isl_ast_expr *ast_expr_sub(<span class='macro'>__isl_take<span class='expansion'>__attribute__((cf_consumed))</span></span> isl_ast_expr *expr1,</td></tr>
<tr><td class="num" id="LN304">304</td><td class="line">	<span class='macro'>__isl_take<span class='expansion'>__attribute__((cf_consumed))</span></span> isl_ast_expr *expr2)</td></tr>
<tr><td class="num" id="LN305">305</td><td class="line">{</td></tr>
<tr><td class="num" id="LN306">306</td><td class="line">	<span class='keyword'>if</span> (!expr1 || !expr2)</td></tr>
<tr><td class="num" id="LN307">307</td><td class="line">		<span class='keyword'>goto</span> error;</td></tr>
<tr><td class="num" id="LN308">308</td><td class="line"> </td></tr>
<tr><td class="num" id="LN309">309</td><td class="line">	<span class='keyword'>if</span> (ast_expr_is_zero(expr2)) {</td></tr>
<tr><td class="num" id="LN310">310</td><td class="line">		isl_ast_expr_free(expr2);</td></tr>
<tr><td class="num" id="LN311">311</td><td class="line">		<span class='keyword'>return</span> expr1;</td></tr>
<tr><td class="num" id="LN312">312</td><td class="line">	}</td></tr>
<tr><td class="num" id="LN313">313</td><td class="line"> </td></tr>
<tr><td class="num" id="LN314">314</td><td class="line">	<span class='keyword'>if</span> (ast_expr_is_zero(expr1)) {</td></tr>
<tr><td class="num" id="LN315">315</td><td class="line">		isl_ast_expr_free(expr1);</td></tr>
<tr><td class="num" id="LN316">316</td><td class="line">		<span class='keyword'>return</span> isl_ast_expr_neg(expr2);</td></tr>
<tr><td class="num" id="LN317">317</td><td class="line">	}</td></tr>
<tr><td class="num" id="LN318">318</td><td class="line"> </td></tr>
<tr><td class="num" id="LN319">319</td><td class="line">	<span class='keyword'>return</span> isl_ast_expr_sub(expr1, expr2);</td></tr>
<tr><td class="num" id="LN320">320</td><td class="line">error:</td></tr>
<tr><td class="num" id="LN321">321</td><td class="line">	isl_ast_expr_free(expr1);</td></tr>
<tr><td class="num" id="LN322">322</td><td class="line">	isl_ast_expr_free(expr2);</td></tr>
<tr><td class="num" id="LN323">323</td><td class="line">	<span class='keyword'>return</span> <span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;</td></tr>
<tr><td class="num" id="LN324">324</td><td class="line">}</td></tr>
<tr><td class="num" id="LN325">325</td><td class="line"> </td></tr>
<tr><td class="num" id="LN326">326</td><td class="line"><span class='comment'>/* Return an isl_ast_expr that represents</span></td></tr>
<tr><td class="num" id="LN327">327</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN328">328</td><td class="line"> <span class='comment'>*	v * (aff mod d)</span></td></tr>
<tr><td class="num" id="LN329">329</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN330">330</td><td class="line"> <span class='comment'>* v is assumed to be non-negative.</span></td></tr>
<tr><td class="num" id="LN331">331</td><td class="line"> <span class='comment'>* The result is simplified in terms of build-&gt;domain.</span></td></tr>
<tr><td class="num" id="LN332">332</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN333">333</td><td class="line"><span class='keyword'>static</span> <span class='macro'>__isl_give<span class='expansion'>__attribute__((cf_returns_retained))</span></span> isl_ast_expr *isl_ast_expr_mod(__isl_keep isl_val *v,</td></tr>
<tr><td class="num" id="LN334">334</td><td class="line">	__isl_keep isl_aff *aff, __isl_keep isl_val *d,</td></tr>
<tr><td class="num" id="LN335">335</td><td class="line">	__isl_keep isl_ast_build *build)</td></tr>
<tr><td class="num" id="LN336">336</td><td class="line">{</td></tr>
<tr><td class="num" id="LN337">337</td><td class="line">	isl_ast_expr *expr;</td></tr>
<tr><td class="num" id="LN338">338</td><td class="line">	isl_ast_expr *c;</td></tr>
<tr><td class="num" id="LN339">339</td><td class="line"> </td></tr>
<tr><td class="num" id="LN340">340</td><td class="line">	<span class='keyword'>if</span> (!aff)</td></tr>
<tr><td class="num" id="LN341">341</td><td class="line">		<span class='keyword'>return</span> <span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;</td></tr>
<tr><td class="num" id="LN342">342</td><td class="line"> </td></tr>
<tr><td class="num" id="LN343">343</td><td class="line">	expr = isl_ast_expr_from_aff(isl_aff_copy(aff), build);</td></tr>
<tr><td class="num" id="LN344">344</td><td class="line"> </td></tr>
<tr><td class="num" id="LN345">345</td><td class="line">	c = isl_ast_expr_from_val(isl_val_copy(d));</td></tr>
<tr><td class="num" id="LN346">346</td><td class="line">	expr = isl_ast_expr_alloc_binary(isl_ast_op_pdiv_r, expr, c);</td></tr>
<tr><td class="num" id="LN347">347</td><td class="line"> </td></tr>
<tr><td class="num" id="LN348">348</td><td class="line">	<span class='keyword'>if</span> (!isl_val_is_one(v)) {</td></tr>
<tr><td class="num" id="LN349">349</td><td class="line">		c = isl_ast_expr_from_val(isl_val_copy(v));</td></tr>
<tr><td class="num" id="LN350">350</td><td class="line">		expr = isl_ast_expr_mul(c, expr);</td></tr>
<tr><td class="num" id="LN351">351</td><td class="line">	}</td></tr>
<tr><td class="num" id="LN352">352</td><td class="line"> </td></tr>
<tr><td class="num" id="LN353">353</td><td class="line">	<span class='keyword'>return</span> expr;</td></tr>
<tr><td class="num" id="LN354">354</td><td class="line">}</td></tr>
<tr><td class="num" id="LN355">355</td><td class="line"> </td></tr>
<tr><td class="num" id="LN356">356</td><td class="line"><span class='comment'>/* Create an isl_ast_expr that scales "expr" by "v".</span></td></tr>
<tr><td class="num" id="LN357">357</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN358">358</td><td class="line"> <span class='comment'>* If v is 1, we simply return expr.</span></td></tr>
<tr><td class="num" id="LN359">359</td><td class="line"> <span class='comment'>* If v is -1, we return</span></td></tr>
<tr><td class="num" id="LN360">360</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN361">361</td><td class="line"> <span class='comment'>*	(isl_ast_op_minus, expr)</span></td></tr>
<tr><td class="num" id="LN362">362</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN363">363</td><td class="line"> <span class='comment'>* Otherwise, we return</span></td></tr>
<tr><td class="num" id="LN364">364</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN365">365</td><td class="line"> <span class='comment'>*	(isl_ast_op_mul, expr(v), expr)</span></td></tr>
<tr><td class="num" id="LN366">366</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN367">367</td><td class="line"><span class='keyword'>static</span> <span class='macro'>__isl_give<span class='expansion'>__attribute__((cf_returns_retained))</span></span> isl_ast_expr *scale(<span class='macro'>__isl_take<span class='expansion'>__attribute__((cf_consumed))</span></span> isl_ast_expr *expr,</td></tr>
<tr><td class="num" id="LN368">368</td><td class="line">	<span class='macro'>__isl_take<span class='expansion'>__attribute__((cf_consumed))</span></span> isl_val *v)</td></tr>
<tr><td class="num" id="LN369">369</td><td class="line">{</td></tr>
<tr><td class="num" id="LN370">370</td><td class="line">	isl_ast_expr *c;</td></tr>
<tr><td class="num" id="LN371">371</td><td class="line"> </td></tr>
<tr><td class="num" id="LN372">372</td><td class="line">	<span class='keyword'>if</span> (!expr || !v)</td></tr>
<tr><td class="num" id="LN373">373</td><td class="line">		<span class='keyword'>goto</span> error;</td></tr>
<tr><td class="num" id="LN374">374</td><td class="line">	<span class='keyword'>if</span> (isl_val_is_one(v)) {</td></tr>
<tr><td class="num" id="LN375">375</td><td class="line">		isl_val_free(v);</td></tr>
<tr><td class="num" id="LN376">376</td><td class="line">		<span class='keyword'>return</span> expr;</td></tr>
<tr><td class="num" id="LN377">377</td><td class="line">	}</td></tr>
<tr><td class="num" id="LN378">378</td><td class="line"> </td></tr>
<tr><td class="num" id="LN379">379</td><td class="line">	<span class='keyword'>if</span> (isl_val_is_negone(v)) {</td></tr>
<tr><td class="num" id="LN380">380</td><td class="line">		isl_val_free(v);</td></tr>
<tr><td class="num" id="LN381">381</td><td class="line">		expr = isl_ast_expr_neg(expr);</td></tr>
<tr><td class="num" id="LN382">382</td><td class="line">	} <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN383">383</td><td class="line">		c = isl_ast_expr_from_val(v);</td></tr>
<tr><td class="num" id="LN384">384</td><td class="line">		expr = isl_ast_expr_mul(c, expr);</td></tr>
<tr><td class="num" id="LN385">385</td><td class="line">	}</td></tr>
<tr><td class="num" id="LN386">386</td><td class="line"> </td></tr>
<tr><td class="num" id="LN387">387</td><td class="line">	<span class='keyword'>return</span> expr;</td></tr>
<tr><td class="num" id="LN388">388</td><td class="line">error:</td></tr>
<tr><td class="num" id="LN389">389</td><td class="line">	isl_val_free(v);</td></tr>
<tr><td class="num" id="LN390">390</td><td class="line">	isl_ast_expr_free(expr);</td></tr>
<tr><td class="num" id="LN391">391</td><td class="line">	<span class='keyword'>return</span> <span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;</td></tr>
<tr><td class="num" id="LN392">392</td><td class="line">}</td></tr>
<tr><td class="num" id="LN393">393</td><td class="line"> </td></tr>
<tr><td class="num" id="LN394">394</td><td class="line"><span class='comment'>/* Add an expression for "*v" times the specified dimension of "ls"</span></td></tr>
<tr><td class="num" id="LN395">395</td><td class="line"> <span class='comment'>* to expr.</span></td></tr>
<tr><td class="num" id="LN396">396</td><td class="line"> <span class='comment'>* If the dimension is an integer division, then this function</span></td></tr>
<tr><td class="num" id="LN397">397</td><td class="line"> <span class='comment'>* may modify data-&gt;cst in order to make the numerator non-negative.</span></td></tr>
<tr><td class="num" id="LN398">398</td><td class="line"> <span class='comment'>* The result is simplified in terms of data-&gt;build-&gt;domain.</span></td></tr>
<tr><td class="num" id="LN399">399</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN400">400</td><td class="line"> <span class='comment'>* Let e be the expression for the specified dimension,</span></td></tr>
<tr><td class="num" id="LN401">401</td><td class="line"> <span class='comment'>* multiplied by the absolute value of "*v".</span></td></tr>
<tr><td class="num" id="LN402">402</td><td class="line"> <span class='comment'>* If "*v" is negative, we create</span></td></tr>
<tr><td class="num" id="LN403">403</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN404">404</td><td class="line"> <span class='comment'>*	(isl_ast_op_sub, expr, e)</span></td></tr>
<tr><td class="num" id="LN405">405</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN406">406</td><td class="line"> <span class='comment'>* except when expr is trivially zero, in which case we create</span></td></tr>
<tr><td class="num" id="LN407">407</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN408">408</td><td class="line"> <span class='comment'>*	(isl_ast_op_minus, e)</span></td></tr>
<tr><td class="num" id="LN409">409</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN410">410</td><td class="line"> <span class='comment'>* instead.</span></td></tr>
<tr><td class="num" id="LN411">411</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN412">412</td><td class="line"> <span class='comment'>* If "*v" is positive, we simply create</span></td></tr>
<tr><td class="num" id="LN413">413</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN414">414</td><td class="line"> <span class='comment'>*	(isl_ast_op_add, expr, e)</span></td></tr>
<tr><td class="num" id="LN415">415</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN416">416</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN417">417</td><td class="line"><span class='keyword'>static</span> <span class='macro'>__isl_give<span class='expansion'>__attribute__((cf_returns_retained))</span></span> isl_ast_expr *isl_ast_expr_add_term(</td></tr>
<tr><td class="num" id="LN418">418</td><td class="line">	<span class='macro'>__isl_take<span class='expansion'>__attribute__((cf_consumed))</span></span> isl_ast_expr *expr,</td></tr>
<tr><td class="num" id="LN419">419</td><td class="line">	__isl_keep isl_local_space *ls, <span class='keyword'>enum</span> isl_dim_type type, <span class='keyword'>int</span> pos,</td></tr>
<tr><td class="num" id="LN420">420</td><td class="line">	<span class='macro'>__isl_take<span class='expansion'>__attribute__((cf_consumed))</span></span> isl_val *v, <span class='keyword'>struct</span> isl_ast_add_term_data *data)</td></tr>
<tr><td class="num" id="LN421">421</td><td class="line">{</td></tr>
<tr><td class="num" id="LN422">422</td><td class="line">	isl_ast_expr *term;</td></tr>
<tr><td class="num" id="LN423">423</td><td class="line"> </td></tr>
<tr><td class="num" id="LN424">424</td><td class="line">	<span class='keyword'>if</span> (!expr)</td></tr>
<tr><td class="num" id="LN425">425</td><td class="line">		<span class='keyword'>return</span> <span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;</td></tr>
<tr><td class="num" id="LN426">426</td><td class="line"> </td></tr>
<tr><td class="num" id="LN427">427</td><td class="line">	data-&gt;v = v;</td></tr>
<tr><td class="num" id="LN428">428</td><td class="line">	term = var(data, ls, type, pos);</td></tr>
<tr><td class="num" id="LN429">429</td><td class="line">	v = data-&gt;v;</td></tr>
<tr><td class="num" id="LN430">430</td><td class="line"> </td></tr>
<tr><td class="num" id="LN431">431</td><td class="line">	<span class='keyword'>if</span> (isl_val_is_neg(v) &amp;&amp; !ast_expr_is_zero(expr)) {</td></tr>
<tr><td class="num" id="LN432">432</td><td class="line">		v = isl_val_neg(v);</td></tr>
<tr><td class="num" id="LN433">433</td><td class="line">		term = scale(term, v);</td></tr>
<tr><td class="num" id="LN434">434</td><td class="line">		<span class='keyword'>return</span> ast_expr_sub(expr, term);</td></tr>
<tr><td class="num" id="LN435">435</td><td class="line">	} <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN436">436</td><td class="line">		term = scale(term, v);</td></tr>
<tr><td class="num" id="LN437">437</td><td class="line">		<span class='keyword'>return</span> ast_expr_add(expr, term);</td></tr>
<tr><td class="num" id="LN438">438</td><td class="line">	}</td></tr>
<tr><td class="num" id="LN439">439</td><td class="line">}</td></tr>
<tr><td class="num" id="LN440">440</td><td class="line"> </td></tr>
<tr><td class="num" id="LN441">441</td><td class="line"><span class='comment'>/* Add an expression for "v" to expr.</span></td></tr>
<tr><td class="num" id="LN442">442</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN443">443</td><td class="line"><span class='keyword'>static</span> <span class='macro'>__isl_give<span class='expansion'>__attribute__((cf_returns_retained))</span></span> isl_ast_expr *isl_ast_expr_add_int(</td></tr>
<tr><td class="num" id="LN444">444</td><td class="line">	<span class='macro'>__isl_take<span class='expansion'>__attribute__((cf_consumed))</span></span> isl_ast_expr *expr, <span class='macro'>__isl_take<span class='expansion'>__attribute__((cf_consumed))</span></span> isl_val *v)</td></tr>
<tr><td class="num" id="LN445">445</td><td class="line">{</td></tr>
<tr><td class="num" id="LN446">446</td><td class="line">	isl_ast_expr *expr_int;</td></tr>
<tr><td class="num" id="LN447">447</td><td class="line"> </td></tr>
<tr><td class="num" id="LN448">448</td><td class="line">	<span class='keyword'>if</span> (!expr || !v)</td></tr>
<tr><td class="num" id="LN449">449</td><td class="line">		<span class='keyword'>goto</span> error;</td></tr>
<tr><td class="num" id="LN450">450</td><td class="line"> </td></tr>
<tr><td class="num" id="LN451">451</td><td class="line">	<span class='keyword'>if</span> (isl_val_is_zero(v)) {</td></tr>
<tr><td class="num" id="LN452">452</td><td class="line">		isl_val_free(v);</td></tr>
<tr><td class="num" id="LN453">453</td><td class="line">		<span class='keyword'>return</span> expr;</td></tr>
<tr><td class="num" id="LN454">454</td><td class="line">	}</td></tr>
<tr><td class="num" id="LN455">455</td><td class="line"> </td></tr>
<tr><td class="num" id="LN456">456</td><td class="line">	<span class='keyword'>if</span> (isl_val_is_neg(v) &amp;&amp; !ast_expr_is_zero(expr)) {</td></tr>
<tr><td class="num" id="LN457">457</td><td class="line">		v = isl_val_neg(v);</td></tr>
<tr><td class="num" id="LN458">458</td><td class="line">		expr_int = isl_ast_expr_from_val(v);</td></tr>
<tr><td class="num" id="LN459">459</td><td class="line">		<span class='keyword'>return</span> ast_expr_sub(expr, expr_int);</td></tr>
<tr><td class="num" id="LN460">460</td><td class="line">	} <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN461">461</td><td class="line">		expr_int = isl_ast_expr_from_val(v);</td></tr>
<tr><td class="num" id="LN462">462</td><td class="line">		<span class='keyword'>return</span> ast_expr_add(expr, expr_int);</td></tr>
<tr><td class="num" id="LN463">463</td><td class="line">	}</td></tr>
<tr><td class="num" id="LN464">464</td><td class="line">error:</td></tr>
<tr><td class="num" id="LN465">465</td><td class="line">	isl_ast_expr_free(expr);</td></tr>
<tr><td class="num" id="LN466">466</td><td class="line">	isl_val_free(v);</td></tr>
<tr><td class="num" id="LN467">467</td><td class="line">	<span class='keyword'>return</span> <span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;</td></tr>
<tr><td class="num" id="LN468">468</td><td class="line">}</td></tr>
<tr><td class="num" id="LN469">469</td><td class="line"> </td></tr>
<tr><td class="num" id="LN470">470</td><td class="line"><span class='comment'>/* Internal data structure used inside extract_modulos.</span></td></tr>
<tr><td class="num" id="LN471">471</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN472">472</td><td class="line"> <span class='comment'>* If any modulo expressions are detected in "aff", then the</span></td></tr>
<tr><td class="num" id="LN473">473</td><td class="line"> <span class='comment'>* expression is removed from "aff" and added to either "pos" or "neg"</span></td></tr>
<tr><td class="num" id="LN474">474</td><td class="line"> <span class='comment'>* depending on the sign of the coefficient of the modulo expression</span></td></tr>
<tr><td class="num" id="LN475">475</td><td class="line"> <span class='comment'>* inside "aff".</span></td></tr>
<tr><td class="num" id="LN476">476</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN477">477</td><td class="line"> <span class='comment'>* "add" is an expression that needs to be added to "aff" at the end of</span></td></tr>
<tr><td class="num" id="LN478">478</td><td class="line"> <span class='comment'>* the computation.  It is NULL as long as no modulos have been extracted.</span></td></tr>
<tr><td class="num" id="LN479">479</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN480">480</td><td class="line"> <span class='comment'>* "i" is the position in "aff" of the div under investigation</span></td></tr>
<tr><td class="num" id="LN481">481</td><td class="line"> <span class='comment'>* "v" is the coefficient in "aff" of the div</span></td></tr>
<tr><td class="num" id="LN482">482</td><td class="line"> <span class='comment'>* "div" is the argument of the div, with the denominator removed</span></td></tr>
<tr><td class="num" id="LN483">483</td><td class="line"> <span class='comment'>* "d" is the original denominator of the argument of the div</span></td></tr>
<tr><td class="num" id="LN484">484</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN485">485</td><td class="line"> <span class='comment'>* "nonneg" is an affine expression that is non-negative over "build"</span></td></tr>
<tr><td class="num" id="LN486">486</td><td class="line"> <span class='comment'>* and that can be used to extract a modulo expression from "div".</span></td></tr>
<tr><td class="num" id="LN487">487</td><td class="line"> <span class='comment'>* In particular, if "sign" is 1, then the coefficients of "nonneg"</span></td></tr>
<tr><td class="num" id="LN488">488</td><td class="line"> <span class='comment'>* are equal to those of "div" modulo "d".  If "sign" is -1, then</span></td></tr>
<tr><td class="num" id="LN489">489</td><td class="line"> <span class='comment'>* the coefficients of "nonneg" are opposite to those of "div" modulo "d".</span></td></tr>
<tr><td class="num" id="LN490">490</td><td class="line"> <span class='comment'>* If "sign" is 0, then no such affine expression has been found (yet).</span></td></tr>
<tr><td class="num" id="LN491">491</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN492">492</td><td class="line"><span class='keyword'>struct</span> isl_extract_mod_data {</td></tr>
<tr><td class="num" id="LN493">493</td><td class="line">	isl_ast_build *build;</td></tr>
<tr><td class="num" id="LN494">494</td><td class="line">	isl_aff *aff;</td></tr>
<tr><td class="num" id="LN495">495</td><td class="line"> </td></tr>
<tr><td class="num" id="LN496">496</td><td class="line">	isl_ast_expr *pos;</td></tr>
<tr><td class="num" id="LN497">497</td><td class="line">	isl_ast_expr *neg;</td></tr>
<tr><td class="num" id="LN498">498</td><td class="line"> </td></tr>
<tr><td class="num" id="LN499">499</td><td class="line">	isl_aff *add;</td></tr>
<tr><td class="num" id="LN500">500</td><td class="line"> </td></tr>
<tr><td class="num" id="LN501">501</td><td class="line">	<span class='keyword'>int</span> i;</td></tr>
<tr><td class="num" id="LN502">502</td><td class="line">	isl_val *v;</td></tr>
<tr><td class="num" id="LN503">503</td><td class="line">	isl_val *d;</td></tr>
<tr><td class="num" id="LN504">504</td><td class="line">	isl_aff *div;</td></tr>
<tr><td class="num" id="LN505">505</td><td class="line"> </td></tr>
<tr><td class="num" id="LN506">506</td><td class="line">	isl_aff *nonneg;</td></tr>
<tr><td class="num" id="LN507">507</td><td class="line">	<span class='keyword'>int</span> sign;</td></tr>
<tr><td class="num" id="LN508">508</td><td class="line">};</td></tr>
<tr><td class="num" id="LN509">509</td><td class="line"> </td></tr>
<tr><td class="num" id="LN510">510</td><td class="line"><span class='comment'>/* Given that data-&gt;v * div_i in data-&gt;aff is equal to</span></td></tr>
<tr><td class="num" id="LN511">511</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN512">512</td><td class="line"> <span class='comment'>*	f * (term - (arg mod d))</span></td></tr>
<tr><td class="num" id="LN513">513</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN514">514</td><td class="line"> <span class='comment'>* with data-&gt;d * f = data-&gt;v, add</span></td></tr>
<tr><td class="num" id="LN515">515</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN516">516</td><td class="line"> <span class='comment'>*	f * term</span></td></tr>
<tr><td class="num" id="LN517">517</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN518">518</td><td class="line"> <span class='comment'>* to data-&gt;add and</span></td></tr>
<tr><td class="num" id="LN519">519</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN520">520</td><td class="line"> <span class='comment'>*	abs(f) * (arg mod d)</span></td></tr>
<tr><td class="num" id="LN521">521</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN522">522</td><td class="line"> <span class='comment'>* to data-&gt;neg or data-&gt;pos depending on the sign of -f.</span></td></tr>
<tr><td class="num" id="LN523">523</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN524">524</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>int</span> extract_term_and_mod(<span class='keyword'>struct</span> isl_extract_mod_data *data,</td></tr>
<tr><td class="num" id="LN525">525</td><td class="line">	<span class='macro'>__isl_take<span class='expansion'>__attribute__((cf_consumed))</span></span> isl_aff *term, <span class='macro'>__isl_take<span class='expansion'>__attribute__((cf_consumed))</span></span> isl_aff *arg)</td></tr>
<tr><td class="num" id="LN526">526</td><td class="line">{</td></tr>
<tr><td class="num" id="LN527">527</td><td class="line">	isl_ast_expr *expr;</td></tr>
<tr><td class="num" id="LN528">528</td><td class="line">	<span class='keyword'>int</span> s;</td></tr>
<tr><td class="num" id="LN529">529</td><td class="line"> </td></tr>
<tr><td class="num" id="LN530">530</td><td class="line">	data-&gt;v = isl_val_div(data-&gt;v, isl_val_copy(data-&gt;d));</td></tr>
<tr><td class="num" id="LN531">531</td><td class="line">	s = isl_val_sgn(data-&gt;v);</td></tr>
<tr><td class="num" id="LN532">532</td><td class="line">	data-&gt;v = isl_val_abs(data-&gt;v);</td></tr>
<tr><td class="num" id="LN533">533</td><td class="line">	expr = isl_ast_expr_mod(data-&gt;v, arg, data-&gt;d, data-&gt;build);</td></tr>
<tr><td class="num" id="LN534">534</td><td class="line">	isl_aff_free(arg);</td></tr>
<tr><td class="num" id="LN535">535</td><td class="line">	<span class='keyword'>if</span> (s &gt; 0)</td></tr>
<tr><td class="num" id="LN536">536</td><td class="line">		data-&gt;neg = ast_expr_add(data-&gt;neg, expr);</td></tr>
<tr><td class="num" id="LN537">537</td><td class="line">	<span class='keyword'>else</span></td></tr>
<tr><td class="num" id="LN538">538</td><td class="line">		data-&gt;pos = ast_expr_add(data-&gt;pos, expr);</td></tr>
<tr><td class="num" id="LN539">539</td><td class="line">	data-&gt;aff = isl_aff_set_coefficient_si(data-&gt;aff,</td></tr>
<tr><td class="num" id="LN540">540</td><td class="line">						isl_dim_div, data-&gt;i, 0);</td></tr>
<tr><td class="num" id="LN541">541</td><td class="line">	<span class='keyword'>if</span> (s &lt; 0)</td></tr>
<tr><td class="num" id="LN542">542</td><td class="line">		data-&gt;v = isl_val_neg(data-&gt;v);</td></tr>
<tr><td class="num" id="LN543">543</td><td class="line">	term = isl_aff_scale_val(data-&gt;div, isl_val_copy(data-&gt;v));</td></tr>
<tr><td class="num" id="LN544">544</td><td class="line"> </td></tr>
<tr><td class="num" id="LN545">545</td><td class="line">	<span class='keyword'>if</span> (!data-&gt;add)</td></tr>
<tr><td class="num" id="LN546">546</td><td class="line">		data-&gt;add = term;</td></tr>
<tr><td class="num" id="LN547">547</td><td class="line">	<span class='keyword'>else</span></td></tr>
<tr><td class="num" id="LN548">548</td><td class="line">		data-&gt;add = isl_aff_add(data-&gt;add, term);</td></tr>
<tr><td class="num" id="LN549">549</td><td class="line">	<span class='keyword'>if</span> (!data-&gt;add)</td></tr>
<tr><td class="num" id="LN550">550</td><td class="line">		<span class='keyword'>return</span> -1;</td></tr>
<tr><td class="num" id="LN551">551</td><td class="line"> </td></tr>
<tr><td class="num" id="LN552">552</td><td class="line">	<span class='keyword'>return</span> 0;</td></tr>
<tr><td class="num" id="LN553">553</td><td class="line">}</td></tr>
<tr><td class="num" id="LN554">554</td><td class="line"> </td></tr>
<tr><td class="num" id="LN555">555</td><td class="line"><span class='comment'>/* Given that data-&gt;v * div_i in data-&gt;aff is of the form</span></td></tr>
<tr><td class="num" id="LN556">556</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN557">557</td><td class="line"> <span class='comment'>*	f * d * floor(div/d)</span></td></tr>
<tr><td class="num" id="LN558">558</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN559">559</td><td class="line"> <span class='comment'>* with div nonnegative on data-&gt;build, rewrite it as</span></td></tr>
<tr><td class="num" id="LN560">560</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN561">561</td><td class="line"> <span class='comment'>*	f * (div - (div mod d)) = f * div - f * (div mod d)</span></td></tr>
<tr><td class="num" id="LN562">562</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN563">563</td><td class="line"> <span class='comment'>* and add</span></td></tr>
<tr><td class="num" id="LN564">564</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN565">565</td><td class="line"> <span class='comment'>*	f * div</span></td></tr>
<tr><td class="num" id="LN566">566</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN567">567</td><td class="line"> <span class='comment'>* to data-&gt;add and</span></td></tr>
<tr><td class="num" id="LN568">568</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN569">569</td><td class="line"> <span class='comment'>*	abs(f) * (div mod d)</span></td></tr>
<tr><td class="num" id="LN570">570</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN571">571</td><td class="line"> <span class='comment'>* to data-&gt;neg or data-&gt;pos depending on the sign of -f.</span></td></tr>
<tr><td class="num" id="LN572">572</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN573">573</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>int</span> extract_mod(<span class='keyword'>struct</span> isl_extract_mod_data *data)</td></tr>
<tr><td class="num" id="LN574">574</td><td class="line">{</td></tr>
<tr><td class="num" id="LN575">575</td><td class="line">	<span class="mrange"><span class='keyword'>return</span> extract_term_and_mod(data, <span class="mrange">isl_aff_copy(data-&gt;div)</span>,</td></tr>
<tr><td class="num"></td><td class="line"><div id="Path6" class="msg msgEvent" style="margin-left:43ex"><table class="msgT"><tr><td valign="top"><div class="PathIndex PathIndexEvent">6</div></td><td><div class="PathNav"><a href="#Path5" title="Previous event (5)">&#x2190;</a></div></td></td><td>Call to function 'isl_aff_copy' returns a Core Foundation object with a +1 retain count</td><td><div class="PathNav"><a href="#EndPath" title="Next event (7)">&#x2192;</a></div></td></tr></table></div></td></tr></span>
<tr><td class="num"></td><td class="line"><div id="EndPath" class="msg msgEvent" style="margin-left:9ex"><table class="msgT"><tr><td valign="top"><div class="PathIndex PathIndexEvent">7</div></td><td><div class="PathNav"><a href="#Path6" title="Previous event (6)">&#x2190;</a></div></td></td><td>Object leaked: allocated object is not referenced later in this execution path and has a retain count of +1</td></tr></table></div></td></tr>
<tr><td class="num" id="LN576">576</td><td class="line">			<span class="mrange">isl_aff_copy(data-&gt;div))</span>;</td></tr>
<tr><td class="num" id="LN577">577</td><td class="line">}</td></tr>
<tr><td class="num" id="LN578">578</td><td class="line"> </td></tr>
<tr><td class="num" id="LN579">579</td><td class="line"><span class='comment'>/* Given that data-&gt;v * div_i in data-&gt;aff is of the form</span></td></tr>
<tr><td class="num" id="LN580">580</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN581">581</td><td class="line"> <span class='comment'>*	f * d * floor(div/d)					(1)</span></td></tr>
<tr><td class="num" id="LN582">582</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN583">583</td><td class="line"> <span class='comment'>* check if div is non-negative on data-&gt;build and, if so,</span></td></tr>
<tr><td class="num" id="LN584">584</td><td class="line"> <span class='comment'>* extract the corresponding modulo from data-&gt;aff.</span></td></tr>
<tr><td class="num" id="LN585">585</td><td class="line"> <span class='comment'>* If not, then check if</span></td></tr>
<tr><td class="num" id="LN586">586</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN587">587</td><td class="line"> <span class='comment'>*	-div + d - 1</span></td></tr>
<tr><td class="num" id="LN588">588</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN589">589</td><td class="line"> <span class='comment'>* is non-negative on data-&gt;build.  If so, replace (1) by</span></td></tr>
<tr><td class="num" id="LN590">590</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN591">591</td><td class="line"> <span class='comment'>*	-f * d * floor((-div + d - 1)/d)</span></td></tr>
<tr><td class="num" id="LN592">592</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN593">593</td><td class="line"> <span class='comment'>* and extract the corresponding modulo from data-&gt;aff.</span></td></tr>
<tr><td class="num" id="LN594">594</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN595">595</td><td class="line"> <span class='comment'>* This function may modify data-&gt;div.</span></td></tr>
<tr><td class="num" id="LN596">596</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN597">597</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>int</span> extract_nonneg_mod(<span class='keyword'>struct</span> isl_extract_mod_data *data)</td></tr>
<tr><td class="num" id="LN598">598</td><td class="line">{</td></tr>
<tr><td class="num" id="LN599">599</td><td class="line">	<span class='keyword'>int</span> mod;</td></tr>
<tr><td class="num" id="LN600">600</td><td class="line"> </td></tr>
<tr><td class="num" id="LN601">601</td><td class="line">	mod = isl_ast_build_aff_is_nonneg(data-&gt;build, data-&gt;div);</td></tr>
<tr><td class="num" id="LN602">602</td><td class="line">	<span class='keyword'>if</span> (<span class="mrange">mod &lt; 0</span>)</td></tr>
<tr><td class="num"></td><td class="line"><div id="Path1" class="msg msgEvent" style="margin-left:13ex"><table class="msgT"><tr><td valign="top"><div class="PathIndex PathIndexEvent">1</div></td><td>Assuming 'mod' is &gt;= 0</td><td><div class="PathNav"><a href="#Path2" title="Next event (2)">&#x2192;</a></div></td></tr></table></div></td></tr>
<tr><td class="num"></td><td class="line"><div id="Path2" class="msg msgControl" style="margin-left:9ex"><table class="msgT"><tr><td valign="top"><div class="PathIndex PathIndexControl">2</div></td><td><div class="PathNav"><a href="#Path1" title="Previous event (1)">&#x2190;</a></div></td></td><td>Taking false branch</td><td><div class="PathNav"><a href="#Path3" title="Next event (3)">&#x2192;</a></div></td></tr></table></div></td></tr>
<tr><td class="num" id="LN603">603</td><td class="line">		<span class='keyword'>goto</span> error;</td></tr>
<tr><td class="num" id="LN604">604</td><td class="line">	<span class='keyword'>if</span> (<span class="mrange">mod</span>)</td></tr>
<tr><td class="num"></td><td class="line"><div id="Path3" class="msg msgEvent" style="margin-left:13ex"><table class="msgT"><tr><td valign="top"><div class="PathIndex PathIndexEvent">3</div></td><td><div class="PathNav"><a href="#Path2" title="Previous event (2)">&#x2190;</a></div></td></td><td>Assuming 'mod' is not equal to 0</td><td><div class="PathNav"><a href="#Path4" title="Next event (4)">&#x2192;</a></div></td></tr></table></div></td></tr>
<tr><td class="num"></td><td class="line"><div id="Path4" class="msg msgControl" style="margin-left:9ex"><table class="msgT"><tr><td valign="top"><div class="PathIndex PathIndexControl">4</div></td><td><div class="PathNav"><a href="#Path3" title="Previous event (3)">&#x2190;</a></div></td></td><td>Taking true branch</td><td><div class="PathNav"><a href="#Path5" title="Next event (5)">&#x2192;</a></div></td></tr></table></div></td></tr>
<tr><td class="num" id="LN605">605</td><td class="line">		<span class='keyword'>return</span> <span class="mrange">extract_mod(data)</span>;</td></tr>
<tr><td class="num"></td><td class="line"><div id="Path5" class="msg msgEvent" style="margin-left:24ex"><table class="msgT"><tr><td valign="top"><div class="PathIndex PathIndexEvent">5</div></td><td><div class="PathNav"><a href="#Path4" title="Previous event (4)">&#x2190;</a></div></td></td><td>Calling 'extract_mod'</td><td><div class="PathNav"><a href="#Path6" title="Next event (6)">&#x2192;</a></div></td></tr></table></div></td></tr>
<tr><td class="num" id="LN606">606</td><td class="line"> </td></tr>
<tr><td class="num" id="LN607">607</td><td class="line">	data-&gt;div = oppose_div_arg(data-&gt;div, isl_val_copy(data-&gt;d));</td></tr>
<tr><td class="num" id="LN608">608</td><td class="line">	mod = isl_ast_build_aff_is_nonneg(data-&gt;build, data-&gt;div);</td></tr>
<tr><td class="num" id="LN609">609</td><td class="line">	<span class='keyword'>if</span> (mod &lt; 0)</td></tr>
<tr><td class="num" id="LN610">610</td><td class="line">		<span class='keyword'>goto</span> error;</td></tr>
<tr><td class="num" id="LN611">611</td><td class="line">	<span class='keyword'>if</span> (mod) {</td></tr>
<tr><td class="num" id="LN612">612</td><td class="line">		data-&gt;v = isl_val_neg(data-&gt;v);</td></tr>
<tr><td class="num" id="LN613">613</td><td class="line">		<span class='keyword'>return</span> extract_mod(data);</td></tr>
<tr><td class="num" id="LN614">614</td><td class="line">	}</td></tr>
<tr><td class="num" id="LN615">615</td><td class="line"> </td></tr>
<tr><td class="num" id="LN616">616</td><td class="line">	<span class='keyword'>return</span> 0;</td></tr>
<tr><td class="num" id="LN617">617</td><td class="line">error:</td></tr>
<tr><td class="num" id="LN618">618</td><td class="line">	data-&gt;aff = isl_aff_free(data-&gt;aff);</td></tr>
<tr><td class="num" id="LN619">619</td><td class="line">	<span class='keyword'>return</span> -1;</td></tr>
<tr><td class="num" id="LN620">620</td><td class="line">}</td></tr>
<tr><td class="num" id="LN621">621</td><td class="line"> </td></tr>
<tr><td class="num" id="LN622">622</td><td class="line"><span class='comment'>/* Is the affine expression of constraint "c" "simpler" than data-&gt;nonneg</span></td></tr>
<tr><td class="num" id="LN623">623</td><td class="line"> <span class='comment'>* for use in extracting a modulo expression?</span></td></tr>
<tr><td class="num" id="LN624">624</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN625">625</td><td class="line"> <span class='comment'>* We currently only consider the constant term of the affine expression.</span></td></tr>
<tr><td class="num" id="LN626">626</td><td class="line"> <span class='comment'>* In particular, we prefer the affine expression with the smallest constant</span></td></tr>
<tr><td class="num" id="LN627">627</td><td class="line"> <span class='comment'>* term.</span></td></tr>
<tr><td class="num" id="LN628">628</td><td class="line"> <span class='comment'>* This means that if there are two constraints, say x &gt;= 0 and -x + 10 &gt;= 0,</span></td></tr>
<tr><td class="num" id="LN629">629</td><td class="line"> <span class='comment'>* then we would pick x &gt;= 0</span></td></tr>
<tr><td class="num" id="LN630">630</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN631">631</td><td class="line"> <span class='comment'>* More detailed heuristics could be used if it turns out that there is a need.</span></td></tr>
<tr><td class="num" id="LN632">632</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN633">633</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>int</span> mod_constraint_is_simpler(<span class='keyword'>struct</span> isl_extract_mod_data *data,</td></tr>
<tr><td class="num" id="LN634">634</td><td class="line">	__isl_keep isl_constraint *c)</td></tr>
<tr><td class="num" id="LN635">635</td><td class="line">{</td></tr>
<tr><td class="num" id="LN636">636</td><td class="line">	isl_val *v1, *v2;</td></tr>
<tr><td class="num" id="LN637">637</td><td class="line">	<span class='keyword'>int</span> simpler;</td></tr>
<tr><td class="num" id="LN638">638</td><td class="line"> </td></tr>
<tr><td class="num" id="LN639">639</td><td class="line">	<span class='keyword'>if</span> (!data-&gt;nonneg)</td></tr>
<tr><td class="num" id="LN640">640</td><td class="line">		<span class='keyword'>return</span> 1;</td></tr>
<tr><td class="num" id="LN641">641</td><td class="line"> </td></tr>
<tr><td class="num" id="LN642">642</td><td class="line">	v1 = isl_val_abs(isl_constraint_get_constant_val(c));</td></tr>
<tr><td class="num" id="LN643">643</td><td class="line">	v2 = isl_val_abs(isl_aff_get_constant_val(data-&gt;nonneg));</td></tr>
<tr><td class="num" id="LN644">644</td><td class="line">	simpler = isl_val_lt(v1, v2);</td></tr>
<tr><td class="num" id="LN645">645</td><td class="line">	isl_val_free(v1);</td></tr>
<tr><td class="num" id="LN646">646</td><td class="line">	isl_val_free(v2);</td></tr>
<tr><td class="num" id="LN647">647</td><td class="line"> </td></tr>
<tr><td class="num" id="LN648">648</td><td class="line">	<span class='keyword'>return</span> simpler;</td></tr>
<tr><td class="num" id="LN649">649</td><td class="line">}</td></tr>
<tr><td class="num" id="LN650">650</td><td class="line"> </td></tr>
<tr><td class="num" id="LN651">651</td><td class="line"><span class='comment'>/* Check if the coefficients of "c" are either equal or opposite to those</span></td></tr>
<tr><td class="num" id="LN652">652</td><td class="line"> <span class='comment'>* of data-&gt;div modulo data-&gt;d.  If so, and if "c" is "simpler" than</span></td></tr>
<tr><td class="num" id="LN653">653</td><td class="line"> <span class='comment'>* data-&gt;nonneg, then replace data-&gt;nonneg by the affine expression of "c"</span></td></tr>
<tr><td class="num" id="LN654">654</td><td class="line"> <span class='comment'>* and set data-&gt;sign accordingly.</span></td></tr>
<tr><td class="num" id="LN655">655</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN656">656</td><td class="line"> <span class='comment'>* Both "c" and data-&gt;div are assumed not to involve any integer divisions.</span></td></tr>
<tr><td class="num" id="LN657">657</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN658">658</td><td class="line"> <span class='comment'>* Before we start the actual comparison, we first quickly check if</span></td></tr>
<tr><td class="num" id="LN659">659</td><td class="line"> <span class='comment'>* "c" and data-&gt;div have the same non-zero coefficients.</span></td></tr>
<tr><td class="num" id="LN660">660</td><td class="line"> <span class='comment'>* If not, then we assume that "c" is not of the desired form.</span></td></tr>
<tr><td class="num" id="LN661">661</td><td class="line"> <span class='comment'>* Note that while the coefficients of data-&gt;div can be reasonably expected</span></td></tr>
<tr><td class="num" id="LN662">662</td><td class="line"> <span class='comment'>* not to involve any coefficients that are multiples of d, "c" may</span></td></tr>
<tr><td class="num" id="LN663">663</td><td class="line"> <span class='comment'>* very well involve such coefficients.  This means that we may actually</span></td></tr>
<tr><td class="num" id="LN664">664</td><td class="line"> <span class='comment'>* miss some cases.</span></td></tr>
<tr><td class="num" id="LN665">665</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN666">666</td><td class="line"> <span class='comment'>* If the constant term is "too large", then the constraint is rejected,</span></td></tr>
<tr><td class="num" id="LN667">667</td><td class="line"> <span class='comment'>* where "too large" is fairly arbitrarily set to 1 &lt;&lt; 15.</span></td></tr>
<tr><td class="num" id="LN668">668</td><td class="line"> <span class='comment'>* We do this to avoid picking up constraints that bound a variable</span></td></tr>
<tr><td class="num" id="LN669">669</td><td class="line"> <span class='comment'>* by a very large number, say the largest or smallest possible</span></td></tr>
<tr><td class="num" id="LN670">670</td><td class="line"> <span class='comment'>* variable in the representation of some integer type.</span></td></tr>
<tr><td class="num" id="LN671">671</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN672">672</td><td class="line"><span class='keyword'>static</span> isl_stat check_parallel_or_opposite(<span class='macro'>__isl_take<span class='expansion'>__attribute__((cf_consumed))</span></span> isl_constraint *c,</td></tr>
<tr><td class="num" id="LN673">673</td><td class="line">	<span class='keyword'>void</span> *user)</td></tr>
<tr><td class="num" id="LN674">674</td><td class="line">{</td></tr>
<tr><td class="num" id="LN675">675</td><td class="line">	<span class='keyword'>struct</span> isl_extract_mod_data *data = user;</td></tr>
<tr><td class="num" id="LN676">676</td><td class="line">	<span class='keyword'>enum</span> isl_dim_type c_type[2] = { isl_dim_param, isl_dim_set };</td></tr>
<tr><td class="num" id="LN677">677</td><td class="line">	<span class='keyword'>enum</span> isl_dim_type a_type[2] = { isl_dim_param, isl_dim_in };</td></tr>
<tr><td class="num" id="LN678">678</td><td class="line">	<span class='keyword'>int</span> i, t;</td></tr>
<tr><td class="num" id="LN679">679</td><td class="line">	<span class='keyword'>int</span> n[2];</td></tr>
<tr><td class="num" id="LN680">680</td><td class="line">	<span class='keyword'>int</span> parallel = 1, opposite = 1;</td></tr>
<tr><td class="num" id="LN681">681</td><td class="line"> </td></tr>
<tr><td class="num" id="LN682">682</td><td class="line">	<span class='keyword'>for</span> (t = 0; t &lt; 2; ++t) {</td></tr>
<tr><td class="num" id="LN683">683</td><td class="line">		n[t] = isl_constraint_dim(c, c_type[t]);</td></tr>
<tr><td class="num" id="LN684">684</td><td class="line">		<span class='keyword'>for</span> (i = 0; i &lt; n[t]; ++i) {</td></tr>
<tr><td class="num" id="LN685">685</td><td class="line">			<span class='keyword'>int</span> a, b;</td></tr>
<tr><td class="num" id="LN686">686</td><td class="line"> </td></tr>
<tr><td class="num" id="LN687">687</td><td class="line">			a = isl_constraint_involves_dims(c, c_type[t], i, 1);</td></tr>
<tr><td class="num" id="LN688">688</td><td class="line">			b = isl_aff_involves_dims(data-&gt;div, a_type[t], i, 1);</td></tr>
<tr><td class="num" id="LN689">689</td><td class="line">			<span class='keyword'>if</span> (a != b)</td></tr>
<tr><td class="num" id="LN690">690</td><td class="line">				parallel = opposite = 0;</td></tr>
<tr><td class="num" id="LN691">691</td><td class="line">		}</td></tr>
<tr><td class="num" id="LN692">692</td><td class="line">	}</td></tr>
<tr><td class="num" id="LN693">693</td><td class="line"> </td></tr>
<tr><td class="num" id="LN694">694</td><td class="line">	<span class='keyword'>if</span> (parallel || opposite) {</td></tr>
<tr><td class="num" id="LN695">695</td><td class="line">		isl_val *v;</td></tr>
<tr><td class="num" id="LN696">696</td><td class="line"> </td></tr>
<tr><td class="num" id="LN697">697</td><td class="line">		v = isl_val_abs(isl_constraint_get_constant_val(c));</td></tr>
<tr><td class="num" id="LN698">698</td><td class="line">		<span class='keyword'>if</span> (isl_val_cmp_si(v, 1 &lt;&lt; 15) &gt; 0)</td></tr>
<tr><td class="num" id="LN699">699</td><td class="line">			parallel = opposite = 0;</td></tr>
<tr><td class="num" id="LN700">700</td><td class="line">		isl_val_free(v);</td></tr>
<tr><td class="num" id="LN701">701</td><td class="line">	}</td></tr>
<tr><td class="num" id="LN702">702</td><td class="line"> </td></tr>
<tr><td class="num" id="LN703">703</td><td class="line">	<span class='keyword'>for</span> (t = 0; t &lt; 2; ++t) {</td></tr>
<tr><td class="num" id="LN704">704</td><td class="line">		<span class='keyword'>for</span> (i = 0; i &lt; n[t]; ++i) {</td></tr>
<tr><td class="num" id="LN705">705</td><td class="line">			isl_val *v1, *v2;</td></tr>
<tr><td class="num" id="LN706">706</td><td class="line"> </td></tr>
<tr><td class="num" id="LN707">707</td><td class="line">			<span class='keyword'>if</span> (!parallel &amp;&amp; !opposite)</td></tr>
<tr><td class="num" id="LN708">708</td><td class="line">				<span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN709">709</td><td class="line">			v1 = isl_constraint_get_coefficient_val(c,</td></tr>
<tr><td class="num" id="LN710">710</td><td class="line">								c_type[t], i);</td></tr>
<tr><td class="num" id="LN711">711</td><td class="line">			v2 = isl_aff_get_coefficient_val(data-&gt;div,</td></tr>
<tr><td class="num" id="LN712">712</td><td class="line">								a_type[t], i);</td></tr>
<tr><td class="num" id="LN713">713</td><td class="line">			<span class='keyword'>if</span> (parallel) {</td></tr>
<tr><td class="num" id="LN714">714</td><td class="line">				v1 = isl_val_sub(v1, isl_val_copy(v2));</td></tr>
<tr><td class="num" id="LN715">715</td><td class="line">				parallel = isl_val_is_divisible_by(v1, data-&gt;d);</td></tr>
<tr><td class="num" id="LN716">716</td><td class="line">				v1 = isl_val_add(v1, isl_val_copy(v2));</td></tr>
<tr><td class="num" id="LN717">717</td><td class="line">			}</td></tr>
<tr><td class="num" id="LN718">718</td><td class="line">			<span class='keyword'>if</span> (opposite) {</td></tr>
<tr><td class="num" id="LN719">719</td><td class="line">				v1 = isl_val_add(v1, isl_val_copy(v2));</td></tr>
<tr><td class="num" id="LN720">720</td><td class="line">				opposite = isl_val_is_divisible_by(v1, data-&gt;d);</td></tr>
<tr><td class="num" id="LN721">721</td><td class="line">			}</td></tr>
<tr><td class="num" id="LN722">722</td><td class="line">			isl_val_free(v1);</td></tr>
<tr><td class="num" id="LN723">723</td><td class="line">			isl_val_free(v2);</td></tr>
<tr><td class="num" id="LN724">724</td><td class="line">		}</td></tr>
<tr><td class="num" id="LN725">725</td><td class="line">	}</td></tr>
<tr><td class="num" id="LN726">726</td><td class="line"> </td></tr>
<tr><td class="num" id="LN727">727</td><td class="line">	<span class='keyword'>if</span> ((parallel || opposite) &amp;&amp; mod_constraint_is_simpler(data, c)) {</td></tr>
<tr><td class="num" id="LN728">728</td><td class="line">		isl_aff_free(data-&gt;nonneg);</td></tr>
<tr><td class="num" id="LN729">729</td><td class="line">		data-&gt;nonneg = isl_constraint_get_aff(c);</td></tr>
<tr><td class="num" id="LN730">730</td><td class="line">		data-&gt;sign = parallel ? 1 : -1;</td></tr>
<tr><td class="num" id="LN731">731</td><td class="line">	}</td></tr>
<tr><td class="num" id="LN732">732</td><td class="line"> </td></tr>
<tr><td class="num" id="LN733">733</td><td class="line">	isl_constraint_free(c);</td></tr>
<tr><td class="num" id="LN734">734</td><td class="line"> </td></tr>
<tr><td class="num" id="LN735">735</td><td class="line">	<span class='keyword'>if</span> (data-&gt;sign != 0 &amp;&amp; data-&gt;nonneg == <span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>)</td></tr>
<tr><td class="num" id="LN736">736</td><td class="line">		<span class='keyword'>return</span> isl_stat_error;</td></tr>
<tr><td class="num" id="LN737">737</td><td class="line"> </td></tr>
<tr><td class="num" id="LN738">738</td><td class="line">	<span class='keyword'>return</span> isl_stat_ok;</td></tr>
<tr><td class="num" id="LN739">739</td><td class="line">}</td></tr>
<tr><td class="num" id="LN740">740</td><td class="line"> </td></tr>
<tr><td class="num" id="LN741">741</td><td class="line"><span class='comment'>/* Given that data-&gt;v * div_i in data-&gt;aff is of the form</span></td></tr>
<tr><td class="num" id="LN742">742</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN743">743</td><td class="line"> <span class='comment'>*	f * d * floor(div/d)					(1)</span></td></tr>
<tr><td class="num" id="LN744">744</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN745">745</td><td class="line"> <span class='comment'>* see if we can find an expression div' that is non-negative over data-&gt;build</span></td></tr>
<tr><td class="num" id="LN746">746</td><td class="line"> <span class='comment'>* and that is related to div through</span></td></tr>
<tr><td class="num" id="LN747">747</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN748">748</td><td class="line"> <span class='comment'>*	div' = div + d * e</span></td></tr>
<tr><td class="num" id="LN749">749</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN750">750</td><td class="line"> <span class='comment'>* or</span></td></tr>
<tr><td class="num" id="LN751">751</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN752">752</td><td class="line"> <span class='comment'>*	div' = -div + d - 1 + d * e</span></td></tr>
<tr><td class="num" id="LN753">753</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN754">754</td><td class="line"> <span class='comment'>* with e some affine expression.</span></td></tr>
<tr><td class="num" id="LN755">755</td><td class="line"> <span class='comment'>* If so, we write (1) as</span></td></tr>
<tr><td class="num" id="LN756">756</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN757">757</td><td class="line"> <span class='comment'>*	f * div + f * (div' mod d)</span></td></tr>
<tr><td class="num" id="LN758">758</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN759">759</td><td class="line"> <span class='comment'>* or</span></td></tr>
<tr><td class="num" id="LN760">760</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN761">761</td><td class="line"> <span class='comment'>*	-f * (-div + d - 1) - f * (div' mod d)</span></td></tr>
<tr><td class="num" id="LN762">762</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN763">763</td><td class="line"> <span class='comment'>* exploiting (in the second case) the fact that</span></td></tr>
<tr><td class="num" id="LN764">764</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN765">765</td><td class="line"> <span class='comment'>*	f * d * floor(div/d) =	-f * d * floor((-div + d - 1)/d)</span></td></tr>
<tr><td class="num" id="LN766">766</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN767">767</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN768">768</td><td class="line"> <span class='comment'>* We first try to find an appropriate expression for div'</span></td></tr>
<tr><td class="num" id="LN769">769</td><td class="line"> <span class='comment'>* from the constraints of data-&gt;build-&gt;domain (which is therefore</span></td></tr>
<tr><td class="num" id="LN770">770</td><td class="line"> <span class='comment'>* guaranteed to be non-negative on data-&gt;build), where we remove</span></td></tr>
<tr><td class="num" id="LN771">771</td><td class="line"> <span class='comment'>* any integer divisions from the constraints and skip this step</span></td></tr>
<tr><td class="num" id="LN772">772</td><td class="line"> <span class='comment'>* if "div" itself involves any integer divisions.</span></td></tr>
<tr><td class="num" id="LN773">773</td><td class="line"> <span class='comment'>* If we cannot find an appropriate expression this way, then</span></td></tr>
<tr><td class="num" id="LN774">774</td><td class="line"> <span class='comment'>* we pass control to extract_nonneg_mod where check</span></td></tr>
<tr><td class="num" id="LN775">775</td><td class="line"> <span class='comment'>* if div or "-div + d -1" themselves happen to be</span></td></tr>
<tr><td class="num" id="LN776">776</td><td class="line"> <span class='comment'>* non-negative on data-&gt;build.</span></td></tr>
<tr><td class="num" id="LN777">777</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN778">778</td><td class="line"> <span class='comment'>* While looking for an appropriate constraint in data-&gt;build-&gt;domain,</span></td></tr>
<tr><td class="num" id="LN779">779</td><td class="line"> <span class='comment'>* we ignore the constant term, so after finding such a constraint,</span></td></tr>
<tr><td class="num" id="LN780">780</td><td class="line"> <span class='comment'>* we still need to fix up the constant term.</span></td></tr>
<tr><td class="num" id="LN781">781</td><td class="line"> <span class='comment'>* In particular, if a is the constant term of "div"</span></td></tr>
<tr><td class="num" id="LN782">782</td><td class="line"> <span class='comment'>* (or d - 1 - the constant term of "div" if data-&gt;sign &lt; 0)</span></td></tr>
<tr><td class="num" id="LN783">783</td><td class="line"> <span class='comment'>* and b is the constant term of the constraint, then we need to find</span></td></tr>
<tr><td class="num" id="LN784">784</td><td class="line"> <span class='comment'>* a non-negative constant c such that</span></td></tr>
<tr><td class="num" id="LN785">785</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN786">786</td><td class="line"> <span class='comment'>*	b + c \equiv a	mod d</span></td></tr>
<tr><td class="num" id="LN787">787</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN788">788</td><td class="line"> <span class='comment'>* We therefore take</span></td></tr>
<tr><td class="num" id="LN789">789</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN790">790</td><td class="line"> <span class='comment'>*	c = (a - b) mod d</span></td></tr>
<tr><td class="num" id="LN791">791</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN792">792</td><td class="line"> <span class='comment'>* and add it to b to obtain the constant term of div'.</span></td></tr>
<tr><td class="num" id="LN793">793</td><td class="line"> <span class='comment'>* If this constant term is "too negative", then we add an appropriate</span></td></tr>
<tr><td class="num" id="LN794">794</td><td class="line"> <span class='comment'>* multiple of d to make it positive.</span></td></tr>
<tr><td class="num" id="LN795">795</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN796">796</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN797">797</td><td class="line"> <span class='comment'>* Note that the above is a only a very simple heuristic for finding an</span></td></tr>
<tr><td class="num" id="LN798">798</td><td class="line"> <span class='comment'>* appropriate expression.  We could try a bit harder by also considering</span></td></tr>
<tr><td class="num" id="LN799">799</td><td class="line"> <span class='comment'>* sums of constraints that involve disjoint sets of variables or</span></td></tr>
<tr><td class="num" id="LN800">800</td><td class="line"> <span class='comment'>* we could consider arbitrary linear combinations of constraints,</span></td></tr>
<tr><td class="num" id="LN801">801</td><td class="line"> <span class='comment'>* although that could potentially be much more expensive as it involves</span></td></tr>
<tr><td class="num" id="LN802">802</td><td class="line"> <span class='comment'>* the solution of an LP problem.</span></td></tr>
<tr><td class="num" id="LN803">803</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN804">804</td><td class="line"> <span class='comment'>* In particular, if v_i is a column vector representing constraint i,</span></td></tr>
<tr><td class="num" id="LN805">805</td><td class="line"> <span class='comment'>* w represents div and e_i is the i-th unit vector, then we are looking</span></td></tr>
<tr><td class="num" id="LN806">806</td><td class="line"> <span class='comment'>* for a solution of the constraints</span></td></tr>
<tr><td class="num" id="LN807">807</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN808">808</td><td class="line"> <span class='comment'>*	\sum_i lambda_i v_i = w + \sum_i alpha_i d e_i</span></td></tr>
<tr><td class="num" id="LN809">809</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN810">810</td><td class="line"> <span class='comment'>* with \lambda_i &gt;= 0 and alpha_i of unrestricted sign.</span></td></tr>
<tr><td class="num" id="LN811">811</td><td class="line"> <span class='comment'>* If we are not just interested in a non-negative expression, but</span></td></tr>
<tr><td class="num" id="LN812">812</td><td class="line"> <span class='comment'>* also in one with a minimal range, then we don't just want</span></td></tr>
<tr><td class="num" id="LN813">813</td><td class="line"> <span class='comment'>* c = \sum_i lambda_i v_i to be non-negative over the domain,</span></td></tr>
<tr><td class="num" id="LN814">814</td><td class="line"> <span class='comment'>* but also beta - c = \sum_i mu_i v_i, where beta is a scalar</span></td></tr>
<tr><td class="num" id="LN815">815</td><td class="line"> <span class='comment'>* that we want to minimize and we now also have to take into account</span></td></tr>
<tr><td class="num" id="LN816">816</td><td class="line"> <span class='comment'>* the constant terms of the constraints.</span></td></tr>
<tr><td class="num" id="LN817">817</td><td class="line"> <span class='comment'>* Alternatively, we could first compute the dual of the domain</span></td></tr>
<tr><td class="num" id="LN818">818</td><td class="line"> <span class='comment'>* and plug in the constraints on the coefficients.</span></td></tr>
<tr><td class="num" id="LN819">819</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN820">820</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>int</span> try_extract_mod(<span class='keyword'>struct</span> isl_extract_mod_data *data)</td></tr>
<tr><td class="num" id="LN821">821</td><td class="line">{</td></tr>
<tr><td class="num" id="LN822">822</td><td class="line">	isl_basic_set *hull;</td></tr>
<tr><td class="num" id="LN823">823</td><td class="line">	isl_val *v1, *v2;</td></tr>
<tr><td class="num" id="LN824">824</td><td class="line">	<span class='keyword'>int</span> r, n;</td></tr>
<tr><td class="num" id="LN825">825</td><td class="line"> </td></tr>
<tr><td class="num" id="LN826">826</td><td class="line">	<span class='keyword'>if</span> (!data-&gt;build)</td></tr>
<tr><td class="num" id="LN827">827</td><td class="line">		<span class='keyword'>goto</span> error;</td></tr>
<tr><td class="num" id="LN828">828</td><td class="line"> </td></tr>
<tr><td class="num" id="LN829">829</td><td class="line">	n = isl_aff_dim(data-&gt;div, isl_dim_div);</td></tr>
<tr><td class="num" id="LN830">830</td><td class="line"> </td></tr>
<tr><td class="num" id="LN831">831</td><td class="line">	<span class='keyword'>if</span> (isl_aff_involves_dims(data-&gt;div, isl_dim_div, 0, n))</td></tr>
<tr><td class="num" id="LN832">832</td><td class="line">		<span class='keyword'>return</span> extract_nonneg_mod(data);</td></tr>
<tr><td class="num" id="LN833">833</td><td class="line"> </td></tr>
<tr><td class="num" id="LN834">834</td><td class="line">	hull = isl_set_simple_hull(isl_set_copy(data-&gt;build-&gt;domain));</td></tr>
<tr><td class="num" id="LN835">835</td><td class="line">	hull = isl_basic_set_remove_divs(hull);</td></tr>
<tr><td class="num" id="LN836">836</td><td class="line">	data-&gt;sign = 0;</td></tr>
<tr><td class="num" id="LN837">837</td><td class="line">	data-&gt;nonneg = <span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;</td></tr>
<tr><td class="num" id="LN838">838</td><td class="line">	r = isl_basic_set_foreach_constraint(hull, &amp;check_parallel_or_opposite,</td></tr>
<tr><td class="num" id="LN839">839</td><td class="line">					data);</td></tr>
<tr><td class="num" id="LN840">840</td><td class="line">	isl_basic_set_free(hull);</td></tr>
<tr><td class="num" id="LN841">841</td><td class="line"> </td></tr>
<tr><td class="num" id="LN842">842</td><td class="line">	<span class='keyword'>if</span> (!data-&gt;sign || r &lt; 0) {</td></tr>
<tr><td class="num" id="LN843">843</td><td class="line">		isl_aff_free(data-&gt;nonneg);</td></tr>
<tr><td class="num" id="LN844">844</td><td class="line">		<span class='keyword'>if</span> (r &lt; 0)</td></tr>
<tr><td class="num" id="LN845">845</td><td class="line">			<span class='keyword'>goto</span> error;</td></tr>
<tr><td class="num" id="LN846">846</td><td class="line">		<span class='keyword'>return</span> extract_nonneg_mod(data);</td></tr>
<tr><td class="num" id="LN847">847</td><td class="line">	}</td></tr>
<tr><td class="num" id="LN848">848</td><td class="line"> </td></tr>
<tr><td class="num" id="LN849">849</td><td class="line">	v1 = isl_aff_get_constant_val(data-&gt;div);</td></tr>
<tr><td class="num" id="LN850">850</td><td class="line">	v2 = isl_aff_get_constant_val(data-&gt;nonneg);</td></tr>
<tr><td class="num" id="LN851">851</td><td class="line">	<span class='keyword'>if</span> (data-&gt;sign &lt; 0) {</td></tr>
<tr><td class="num" id="LN852">852</td><td class="line">		v1 = isl_val_neg(v1);</td></tr>
<tr><td class="num" id="LN853">853</td><td class="line">		v1 = isl_val_add(v1, isl_val_copy(data-&gt;d));</td></tr>
<tr><td class="num" id="LN854">854</td><td class="line">		v1 = isl_val_sub_ui(v1, 1);</td></tr>
<tr><td class="num" id="LN855">855</td><td class="line">	}</td></tr>
<tr><td class="num" id="LN856">856</td><td class="line">	v1 = isl_val_sub(v1, isl_val_copy(v2));</td></tr>
<tr><td class="num" id="LN857">857</td><td class="line">	v1 = isl_val_mod(v1, isl_val_copy(data-&gt;d));</td></tr>
<tr><td class="num" id="LN858">858</td><td class="line">	v1 = isl_val_add(v1, v2);</td></tr>
<tr><td class="num" id="LN859">859</td><td class="line">	v2 = isl_val_div(isl_val_copy(v1), isl_val_copy(data-&gt;d));</td></tr>
<tr><td class="num" id="LN860">860</td><td class="line">	v2 = isl_val_ceil(v2);</td></tr>
<tr><td class="num" id="LN861">861</td><td class="line">	<span class='keyword'>if</span> (isl_val_is_neg(v2)) {</td></tr>
<tr><td class="num" id="LN862">862</td><td class="line">		v2 = isl_val_mul(v2, isl_val_copy(data-&gt;d));</td></tr>
<tr><td class="num" id="LN863">863</td><td class="line">		v1 = isl_val_sub(v1, isl_val_copy(v2));</td></tr>
<tr><td class="num" id="LN864">864</td><td class="line">	}</td></tr>
<tr><td class="num" id="LN865">865</td><td class="line">	data-&gt;nonneg = isl_aff_set_constant_val(data-&gt;nonneg, v1);</td></tr>
<tr><td class="num" id="LN866">866</td><td class="line">	isl_val_free(v2);</td></tr>
<tr><td class="num" id="LN867">867</td><td class="line"> </td></tr>
<tr><td class="num" id="LN868">868</td><td class="line">	<span class='keyword'>if</span> (data-&gt;sign &lt; 0) {</td></tr>
<tr><td class="num" id="LN869">869</td><td class="line">		data-&gt;div = oppose_div_arg(data-&gt;div, isl_val_copy(data-&gt;d));</td></tr>
<tr><td class="num" id="LN870">870</td><td class="line">		data-&gt;v = isl_val_neg(data-&gt;v);</td></tr>
<tr><td class="num" id="LN871">871</td><td class="line">	}</td></tr>
<tr><td class="num" id="LN872">872</td><td class="line"> </td></tr>
<tr><td class="num" id="LN873">873</td><td class="line">	<span class='keyword'>return</span> extract_term_and_mod(data,</td></tr>
<tr><td class="num" id="LN874">874</td><td class="line">				    isl_aff_copy(data-&gt;div), data-&gt;nonneg);</td></tr>
<tr><td class="num" id="LN875">875</td><td class="line">error:</td></tr>
<tr><td class="num" id="LN876">876</td><td class="line">	data-&gt;aff = isl_aff_free(data-&gt;aff);</td></tr>
<tr><td class="num" id="LN877">877</td><td class="line">	<span class='keyword'>return</span> -1;</td></tr>
<tr><td class="num" id="LN878">878</td><td class="line">}</td></tr>
<tr><td class="num" id="LN879">879</td><td class="line"> </td></tr>
<tr><td class="num" id="LN880">880</td><td class="line"><span class='comment'>/* Check if "data-&gt;aff" involves any (implicit) modulo computations based</span></td></tr>
<tr><td class="num" id="LN881">881</td><td class="line"> <span class='comment'>* on div "data-&gt;i".</span></td></tr>
<tr><td class="num" id="LN882">882</td><td class="line"> <span class='comment'>* If so, remove them from aff and add expressions corresponding</span></td></tr>
<tr><td class="num" id="LN883">883</td><td class="line"> <span class='comment'>* to those modulo computations to data-&gt;pos and/or data-&gt;neg.</span></td></tr>
<tr><td class="num" id="LN884">884</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN885">885</td><td class="line"> <span class='comment'>* "aff" is assumed to be an integer affine expression.</span></td></tr>
<tr><td class="num" id="LN886">886</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN887">887</td><td class="line"> <span class='comment'>* In particular, check if (v * div_j) is of the form</span></td></tr>
<tr><td class="num" id="LN888">888</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN889">889</td><td class="line"> <span class='comment'>*	f * m * floor(a / m)</span></td></tr>
<tr><td class="num" id="LN890">890</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN891">891</td><td class="line"> <span class='comment'>* and, if so, rewrite it as</span></td></tr>
<tr><td class="num" id="LN892">892</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN893">893</td><td class="line"> <span class='comment'>*	f * (a - (a mod m)) = f * a - f * (a mod m)</span></td></tr>
<tr><td class="num" id="LN894">894</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN895">895</td><td class="line"> <span class='comment'>* and extract out -f * (a mod m).</span></td></tr>
<tr><td class="num" id="LN896">896</td><td class="line"> <span class='comment'>* In particular, if f &gt; 0, we add (f * (a mod m)) to *neg.</span></td></tr>
<tr><td class="num" id="LN897">897</td><td class="line"> <span class='comment'>* If f &lt; 0, we add ((-f) * (a mod m)) to *pos.</span></td></tr>
<tr><td class="num" id="LN898">898</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN899">899</td><td class="line"> <span class='comment'>* Note that in order to represent "a mod m" as</span></td></tr>
<tr><td class="num" id="LN900">900</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN901">901</td><td class="line"> <span class='comment'>*	(isl_ast_op_pdiv_r, a, m)</span></td></tr>
<tr><td class="num" id="LN902">902</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN903">903</td><td class="line"> <span class='comment'>* we need to make sure that a is non-negative.</span></td></tr>
<tr><td class="num" id="LN904">904</td><td class="line"> <span class='comment'>* If not, we check if "-a + m - 1" is non-negative.</span></td></tr>
<tr><td class="num" id="LN905">905</td><td class="line"> <span class='comment'>* If so, we can rewrite</span></td></tr>
<tr><td class="num" id="LN906">906</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN907">907</td><td class="line"> <span class='comment'>*	floor(a/m) = -ceil(-a/m) = -floor((-a + m - 1)/m)</span></td></tr>
<tr><td class="num" id="LN908">908</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN909">909</td><td class="line"> <span class='comment'>* and still extract a modulo.</span></td></tr>
<tr><td class="num" id="LN910">910</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN911">911</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>int</span> extract_modulo(<span class='keyword'>struct</span> isl_extract_mod_data *data)</td></tr>
<tr><td class="num" id="LN912">912</td><td class="line">{</td></tr>
<tr><td class="num" id="LN913">913</td><td class="line">	data-&gt;div = isl_aff_get_div(data-&gt;aff, data-&gt;i);</td></tr>
<tr><td class="num" id="LN914">914</td><td class="line">	data-&gt;d = isl_aff_get_denominator_val(data-&gt;div);</td></tr>
<tr><td class="num" id="LN915">915</td><td class="line">	<span class='keyword'>if</span> (isl_val_is_divisible_by(data-&gt;v, data-&gt;d)) {</td></tr>
<tr><td class="num" id="LN916">916</td><td class="line">		data-&gt;div = isl_aff_scale_val(data-&gt;div, isl_val_copy(data-&gt;d));</td></tr>
<tr><td class="num" id="LN917">917</td><td class="line">		<span class='keyword'>if</span> (try_extract_mod(data) &lt; 0)</td></tr>
<tr><td class="num" id="LN918">918</td><td class="line">			data-&gt;aff = isl_aff_free(data-&gt;aff);</td></tr>
<tr><td class="num" id="LN919">919</td><td class="line">	}</td></tr>
<tr><td class="num" id="LN920">920</td><td class="line">	isl_aff_free(data-&gt;div);</td></tr>
<tr><td class="num" id="LN921">921</td><td class="line">	isl_val_free(data-&gt;d);</td></tr>
<tr><td class="num" id="LN922">922</td><td class="line">	<span class='keyword'>return</span> 0;</td></tr>
<tr><td class="num" id="LN923">923</td><td class="line">}</td></tr>
<tr><td class="num" id="LN924">924</td><td class="line"> </td></tr>
<tr><td class="num" id="LN925">925</td><td class="line"><span class='comment'>/* Check if "aff" involves any (implicit) modulo computations.</span></td></tr>
<tr><td class="num" id="LN926">926</td><td class="line"> <span class='comment'>* If so, remove them from aff and add expressions corresponding</span></td></tr>
<tr><td class="num" id="LN927">927</td><td class="line"> <span class='comment'>* to those modulo computations to *pos and/or *neg.</span></td></tr>
<tr><td class="num" id="LN928">928</td><td class="line"> <span class='comment'>* We only do this if the option ast_build_prefer_pdiv is set.</span></td></tr>
<tr><td class="num" id="LN929">929</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN930">930</td><td class="line"> <span class='comment'>* "aff" is assumed to be an integer affine expression.</span></td></tr>
<tr><td class="num" id="LN931">931</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN932">932</td><td class="line"> <span class='comment'>* A modulo expression is of the form</span></td></tr>
<tr><td class="num" id="LN933">933</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN934">934</td><td class="line"> <span class='comment'>*	a mod m = a - m * floor(a / m)</span></td></tr>
<tr><td class="num" id="LN935">935</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN936">936</td><td class="line"> <span class='comment'>* To detect them in aff, we look for terms of the form</span></td></tr>
<tr><td class="num" id="LN937">937</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN938">938</td><td class="line"> <span class='comment'>*	f * m * floor(a / m)</span></td></tr>
<tr><td class="num" id="LN939">939</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN940">940</td><td class="line"> <span class='comment'>* rewrite them as</span></td></tr>
<tr><td class="num" id="LN941">941</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN942">942</td><td class="line"> <span class='comment'>*	f * (a - (a mod m)) = f * a - f * (a mod m)</span></td></tr>
<tr><td class="num" id="LN943">943</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN944">944</td><td class="line"> <span class='comment'>* and extract out -f * (a mod m).</span></td></tr>
<tr><td class="num" id="LN945">945</td><td class="line"> <span class='comment'>* In particular, if f &gt; 0, we add (f * (a mod m)) to *neg.</span></td></tr>
<tr><td class="num" id="LN946">946</td><td class="line"> <span class='comment'>* If f &lt; 0, we add ((-f) * (a mod m)) to *pos.</span></td></tr>
<tr><td class="num" id="LN947">947</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN948">948</td><td class="line"><span class='keyword'>static</span> <span class='macro'>__isl_give<span class='expansion'>__attribute__((cf_returns_retained))</span></span> isl_aff *extract_modulos(<span class='macro'>__isl_take<span class='expansion'>__attribute__((cf_consumed))</span></span> isl_aff *aff,</td></tr>
<tr><td class="num" id="LN949">949</td><td class="line">	__isl_keep isl_ast_expr **pos, __isl_keep isl_ast_expr **neg,</td></tr>
<tr><td class="num" id="LN950">950</td><td class="line">	__isl_keep isl_ast_build *build)</td></tr>
<tr><td class="num" id="LN951">951</td><td class="line">{</td></tr>
<tr><td class="num" id="LN952">952</td><td class="line">	<span class='keyword'>struct</span> isl_extract_mod_data data = { build, aff, *pos, *neg };</td></tr>
<tr><td class="num" id="LN953">953</td><td class="line">	isl_ctx *ctx;</td></tr>
<tr><td class="num" id="LN954">954</td><td class="line">	<span class='keyword'>int</span> n;</td></tr>
<tr><td class="num" id="LN955">955</td><td class="line"> </td></tr>
<tr><td class="num" id="LN956">956</td><td class="line">	<span class='keyword'>if</span> (!aff)</td></tr>
<tr><td class="num" id="LN957">957</td><td class="line">		<span class='keyword'>return</span> <span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;</td></tr>
<tr><td class="num" id="LN958">958</td><td class="line"> </td></tr>
<tr><td class="num" id="LN959">959</td><td class="line">	ctx = isl_aff_get_ctx(aff);</td></tr>
<tr><td class="num" id="LN960">960</td><td class="line">	<span class='keyword'>if</span> (!isl_options_get_ast_build_prefer_pdiv(ctx))</td></tr>
<tr><td class="num" id="LN961">961</td><td class="line">		<span class='keyword'>return</span> aff;</td></tr>
<tr><td class="num" id="LN962">962</td><td class="line"> </td></tr>
<tr><td class="num" id="LN963">963</td><td class="line">	n = isl_aff_dim(data.aff, isl_dim_div);</td></tr>
<tr><td class="num" id="LN964">964</td><td class="line">	<span class='keyword'>for</span> (data.i = 0; data.i &lt; n; ++data.i) {</td></tr>
<tr><td class="num" id="LN965">965</td><td class="line">		data.v = isl_aff_get_coefficient_val(data.aff,</td></tr>
<tr><td class="num" id="LN966">966</td><td class="line">							isl_dim_div, data.i);</td></tr>
<tr><td class="num" id="LN967">967</td><td class="line">		<span class='keyword'>if</span> (!data.v)</td></tr>
<tr><td class="num" id="LN968">968</td><td class="line">			<span class='keyword'>return</span> isl_aff_free(aff);</td></tr>
<tr><td class="num" id="LN969">969</td><td class="line">		<span class='keyword'>if</span> (isl_val_is_zero(data.v) ||</td></tr>
<tr><td class="num" id="LN970">970</td><td class="line">		    isl_val_is_one(data.v) || isl_val_is_negone(data.v)) {</td></tr>
<tr><td class="num" id="LN971">971</td><td class="line">			isl_val_free(data.v);</td></tr>
<tr><td class="num" id="LN972">972</td><td class="line">			<span class='keyword'>continue</span>;</td></tr>
<tr><td class="num" id="LN973">973</td><td class="line">		}</td></tr>
<tr><td class="num" id="LN974">974</td><td class="line">		<span class='keyword'>if</span> (extract_modulo(&amp;data) &lt; 0)</td></tr>
<tr><td class="num" id="LN975">975</td><td class="line">			data.aff = isl_aff_free(data.aff);</td></tr>
<tr><td class="num" id="LN976">976</td><td class="line">		isl_val_free(data.v);</td></tr>
<tr><td class="num" id="LN977">977</td><td class="line">		<span class='keyword'>if</span> (!data.aff)</td></tr>
<tr><td class="num" id="LN978">978</td><td class="line">			<span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN979">979</td><td class="line">	}</td></tr>
<tr><td class="num" id="LN980">980</td><td class="line"> </td></tr>
<tr><td class="num" id="LN981">981</td><td class="line">	<span class='keyword'>if</span> (data.add)</td></tr>
<tr><td class="num" id="LN982">982</td><td class="line">		data.aff = isl_aff_add(data.aff, data.add);</td></tr>
<tr><td class="num" id="LN983">983</td><td class="line"> </td></tr>
<tr><td class="num" id="LN984">984</td><td class="line">	*pos = data.pos;</td></tr>
<tr><td class="num" id="LN985">985</td><td class="line">	*neg = data.neg;</td></tr>
<tr><td class="num" id="LN986">986</td><td class="line">	<span class='keyword'>return</span> data.aff;</td></tr>
<tr><td class="num" id="LN987">987</td><td class="line">}</td></tr>
<tr><td class="num" id="LN988">988</td><td class="line"> </td></tr>
<tr><td class="num" id="LN989">989</td><td class="line"><span class='comment'>/* Check if aff involves any non-integer coefficients.</span></td></tr>
<tr><td class="num" id="LN990">990</td><td class="line"> <span class='comment'>* If so, split aff into</span></td></tr>
<tr><td class="num" id="LN991">991</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN992">992</td><td class="line"> <span class='comment'>*	aff = aff1 + (aff2 / d)</span></td></tr>
<tr><td class="num" id="LN993">993</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN994">994</td><td class="line"> <span class='comment'>* with both aff1 and aff2 having only integer coefficients.</span></td></tr>
<tr><td class="num" id="LN995">995</td><td class="line"> <span class='comment'>* Return aff1 and add (aff2 / d) to *expr.</span></td></tr>
<tr><td class="num" id="LN996">996</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN997">997</td><td class="line"><span class='keyword'>static</span> <span class='macro'>__isl_give<span class='expansion'>__attribute__((cf_returns_retained))</span></span> isl_aff *extract_rational(<span class='macro'>__isl_take<span class='expansion'>__attribute__((cf_consumed))</span></span> isl_aff *aff,</td></tr>
<tr><td class="num" id="LN998">998</td><td class="line">	__isl_keep isl_ast_expr **expr, __isl_keep isl_ast_build *build)</td></tr>
<tr><td class="num" id="LN999">999</td><td class="line">{</td></tr>
<tr><td class="num" id="LN1000">1000</td><td class="line">	<span class='keyword'>int</span> i, j, n;</td></tr>
<tr><td class="num" id="LN1001">1001</td><td class="line">	isl_aff *rat = <span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;</td></tr>
<tr><td class="num" id="LN1002">1002</td><td class="line">	isl_local_space *ls = <span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;</td></tr>
<tr><td class="num" id="LN1003">1003</td><td class="line">	isl_ast_expr *rat_expr;</td></tr>
<tr><td class="num" id="LN1004">1004</td><td class="line">	isl_val *v, *d;</td></tr>
<tr><td class="num" id="LN1005">1005</td><td class="line">	<span class='keyword'>enum</span> isl_dim_type t[] = { isl_dim_param, isl_dim_in, isl_dim_div };</td></tr>
<tr><td class="num" id="LN1006">1006</td><td class="line">	<span class='keyword'>enum</span> isl_dim_type l[] = { isl_dim_param, isl_dim_set, isl_dim_div };</td></tr>
<tr><td class="num" id="LN1007">1007</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1008">1008</td><td class="line">	<span class='keyword'>if</span> (!aff)</td></tr>
<tr><td class="num" id="LN1009">1009</td><td class="line">		<span class='keyword'>return</span> <span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;</td></tr>
<tr><td class="num" id="LN1010">1010</td><td class="line">	d = isl_aff_get_denominator_val(aff);</td></tr>
<tr><td class="num" id="LN1011">1011</td><td class="line">	<span class='keyword'>if</span> (!d)</td></tr>
<tr><td class="num" id="LN1012">1012</td><td class="line">		<span class='keyword'>goto</span> error;</td></tr>
<tr><td class="num" id="LN1013">1013</td><td class="line">	<span class='keyword'>if</span> (isl_val_is_one(d)) {</td></tr>
<tr><td class="num" id="LN1014">1014</td><td class="line">		isl_val_free(d);</td></tr>
<tr><td class="num" id="LN1015">1015</td><td class="line">		<span class='keyword'>return</span> aff;</td></tr>
<tr><td class="num" id="LN1016">1016</td><td class="line">	}</td></tr>
<tr><td class="num" id="LN1017">1017</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1018">1018</td><td class="line">	aff = isl_aff_scale_val(aff, isl_val_copy(d));</td></tr>
<tr><td class="num" id="LN1019">1019</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1020">1020</td><td class="line">	ls = isl_aff_get_domain_local_space(aff);</td></tr>
<tr><td class="num" id="LN1021">1021</td><td class="line">	rat = isl_aff_zero_on_domain(isl_local_space_copy(ls));</td></tr>
<tr><td class="num" id="LN1022">1022</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1023">1023</td><td class="line">	<span class='keyword'>for</span> (i = 0; i &lt; 3; ++i) {</td></tr>
<tr><td class="num" id="LN1024">1024</td><td class="line">		n = isl_aff_dim(aff, t[i]);</td></tr>
<tr><td class="num" id="LN1025">1025</td><td class="line">		<span class='keyword'>for</span> (j = 0; j &lt; n; ++j) {</td></tr>
<tr><td class="num" id="LN1026">1026</td><td class="line">			isl_aff *rat_j;</td></tr>
<tr><td class="num" id="LN1027">1027</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1028">1028</td><td class="line">			v = isl_aff_get_coefficient_val(aff, t[i], j);</td></tr>
<tr><td class="num" id="LN1029">1029</td><td class="line">			<span class='keyword'>if</span> (!v)</td></tr>
<tr><td class="num" id="LN1030">1030</td><td class="line">				<span class='keyword'>goto</span> error;</td></tr>
<tr><td class="num" id="LN1031">1031</td><td class="line">			<span class='keyword'>if</span> (isl_val_is_divisible_by(v, d)) {</td></tr>
<tr><td class="num" id="LN1032">1032</td><td class="line">				isl_val_free(v);</td></tr>
<tr><td class="num" id="LN1033">1033</td><td class="line">				<span class='keyword'>continue</span>;</td></tr>
<tr><td class="num" id="LN1034">1034</td><td class="line">			}</td></tr>
<tr><td class="num" id="LN1035">1035</td><td class="line">			rat_j = isl_aff_var_on_domain(isl_local_space_copy(ls),</td></tr>
<tr><td class="num" id="LN1036">1036</td><td class="line">							l[i], j);</td></tr>
<tr><td class="num" id="LN1037">1037</td><td class="line">			rat_j = isl_aff_scale_val(rat_j, v);</td></tr>
<tr><td class="num" id="LN1038">1038</td><td class="line">			rat = isl_aff_add(rat, rat_j);</td></tr>
<tr><td class="num" id="LN1039">1039</td><td class="line">		}</td></tr>
<tr><td class="num" id="LN1040">1040</td><td class="line">	}</td></tr>
<tr><td class="num" id="LN1041">1041</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1042">1042</td><td class="line">	v = isl_aff_get_constant_val(aff);</td></tr>
<tr><td class="num" id="LN1043">1043</td><td class="line">	<span class='keyword'>if</span> (isl_val_is_divisible_by(v, d)) {</td></tr>
<tr><td class="num" id="LN1044">1044</td><td class="line">		isl_val_free(v);</td></tr>
<tr><td class="num" id="LN1045">1045</td><td class="line">	} <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN1046">1046</td><td class="line">		isl_aff *rat_0;</td></tr>
<tr><td class="num" id="LN1047">1047</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1048">1048</td><td class="line">		rat_0 = isl_aff_val_on_domain(isl_local_space_copy(ls), v);</td></tr>
<tr><td class="num" id="LN1049">1049</td><td class="line">		rat = isl_aff_add(rat, rat_0);</td></tr>
<tr><td class="num" id="LN1050">1050</td><td class="line">	}</td></tr>
<tr><td class="num" id="LN1051">1051</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1052">1052</td><td class="line">	isl_local_space_free(ls);</td></tr>
<tr><td class="num" id="LN1053">1053</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1054">1054</td><td class="line">	aff = isl_aff_sub(aff, isl_aff_copy(rat));</td></tr>
<tr><td class="num" id="LN1055">1055</td><td class="line">	aff = isl_aff_scale_down_val(aff, isl_val_copy(d));</td></tr>
<tr><td class="num" id="LN1056">1056</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1057">1057</td><td class="line">	rat_expr = isl_ast_expr_from_aff(rat, build);</td></tr>
<tr><td class="num" id="LN1058">1058</td><td class="line">	rat_expr = isl_ast_expr_div(rat_expr, isl_ast_expr_from_val(d));</td></tr>
<tr><td class="num" id="LN1059">1059</td><td class="line">	*expr = ast_expr_add(*expr, rat_expr);</td></tr>
<tr><td class="num" id="LN1060">1060</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1061">1061</td><td class="line">	<span class='keyword'>return</span> aff;</td></tr>
<tr><td class="num" id="LN1062">1062</td><td class="line">error:</td></tr>
<tr><td class="num" id="LN1063">1063</td><td class="line">	isl_aff_free(rat);</td></tr>
<tr><td class="num" id="LN1064">1064</td><td class="line">	isl_local_space_free(ls);</td></tr>
<tr><td class="num" id="LN1065">1065</td><td class="line">	isl_aff_free(aff);</td></tr>
<tr><td class="num" id="LN1066">1066</td><td class="line">	isl_val_free(d);</td></tr>
<tr><td class="num" id="LN1067">1067</td><td class="line">	<span class='keyword'>return</span> <span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;</td></tr>
<tr><td class="num" id="LN1068">1068</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1069">1069</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1070">1070</td><td class="line"><span class='comment'>/* Construct an isl_ast_expr that evaluates the affine expression "aff",</span></td></tr>
<tr><td class="num" id="LN1071">1071</td><td class="line"> <span class='comment'>* The result is simplified in terms of build-&gt;domain.</span></td></tr>
<tr><td class="num" id="LN1072">1072</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN1073">1073</td><td class="line"> <span class='comment'>* We first extract hidden modulo computations from the affine expression</span></td></tr>
<tr><td class="num" id="LN1074">1074</td><td class="line"> <span class='comment'>* and then add terms for each variable with a non-zero coefficient.</span></td></tr>
<tr><td class="num" id="LN1075">1075</td><td class="line"> <span class='comment'>* Finally, if the affine expression has a non-trivial denominator,</span></td></tr>
<tr><td class="num" id="LN1076">1076</td><td class="line"> <span class='comment'>* we divide the resulting isl_ast_expr by this denominator.</span></td></tr>
<tr><td class="num" id="LN1077">1077</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN1078">1078</td><td class="line"><span class='macro'>__isl_give<span class='expansion'>__attribute__((cf_returns_retained))</span></span> isl_ast_expr *isl_ast_expr_from_aff(<span class='macro'>__isl_take<span class='expansion'>__attribute__((cf_consumed))</span></span> isl_aff *aff,</td></tr>
<tr><td class="num" id="LN1079">1079</td><td class="line">	__isl_keep isl_ast_build *build)</td></tr>
<tr><td class="num" id="LN1080">1080</td><td class="line">{</td></tr>
<tr><td class="num" id="LN1081">1081</td><td class="line">	<span class='keyword'>int</span> i, j;</td></tr>
<tr><td class="num" id="LN1082">1082</td><td class="line">	<span class='keyword'>int</span> n;</td></tr>
<tr><td class="num" id="LN1083">1083</td><td class="line">	isl_val *v;</td></tr>
<tr><td class="num" id="LN1084">1084</td><td class="line">	isl_ctx *ctx = isl_aff_get_ctx(aff);</td></tr>
<tr><td class="num" id="LN1085">1085</td><td class="line">	isl_ast_expr *expr, *expr_neg;</td></tr>
<tr><td class="num" id="LN1086">1086</td><td class="line">	<span class='keyword'>enum</span> isl_dim_type t[] = { isl_dim_param, isl_dim_in, isl_dim_div };</td></tr>
<tr><td class="num" id="LN1087">1087</td><td class="line">	<span class='keyword'>enum</span> isl_dim_type l[] = { isl_dim_param, isl_dim_set, isl_dim_div };</td></tr>
<tr><td class="num" id="LN1088">1088</td><td class="line">	isl_local_space *ls;</td></tr>
<tr><td class="num" id="LN1089">1089</td><td class="line">	<span class='keyword'>struct</span> isl_ast_add_term_data data;</td></tr>
<tr><td class="num" id="LN1090">1090</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1091">1091</td><td class="line">	<span class='keyword'>if</span> (!aff)</td></tr>
<tr><td class="num" id="LN1092">1092</td><td class="line">		<span class='keyword'>return</span> <span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;</td></tr>
<tr><td class="num" id="LN1093">1093</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1094">1094</td><td class="line">	expr = isl_ast_expr_alloc_int_si(ctx, 0);</td></tr>
<tr><td class="num" id="LN1095">1095</td><td class="line">	expr_neg = isl_ast_expr_alloc_int_si(ctx, 0);</td></tr>
<tr><td class="num" id="LN1096">1096</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1097">1097</td><td class="line">	aff = extract_rational(aff, &amp;expr, build);</td></tr>
<tr><td class="num" id="LN1098">1098</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1099">1099</td><td class="line">	aff = extract_modulos(aff, &amp;expr, &amp;expr_neg, build);</td></tr>
<tr><td class="num" id="LN1100">1100</td><td class="line">	expr = ast_expr_sub(expr, expr_neg);</td></tr>
<tr><td class="num" id="LN1101">1101</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1102">1102</td><td class="line">	ls = isl_aff_get_domain_local_space(aff);</td></tr>
<tr><td class="num" id="LN1103">1103</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1104">1104</td><td class="line">	data.build = build;</td></tr>
<tr><td class="num" id="LN1105">1105</td><td class="line">	data.cst = isl_aff_get_constant_val(aff);</td></tr>
<tr><td class="num" id="LN1106">1106</td><td class="line">	<span class='keyword'>for</span> (i = 0; i &lt; 3; ++i) {</td></tr>
<tr><td class="num" id="LN1107">1107</td><td class="line">		n = isl_aff_dim(aff, t[i]);</td></tr>
<tr><td class="num" id="LN1108">1108</td><td class="line">		<span class='keyword'>for</span> (j = 0; j &lt; n; ++j) {</td></tr>
<tr><td class="num" id="LN1109">1109</td><td class="line">			v = isl_aff_get_coefficient_val(aff, t[i], j);</td></tr>
<tr><td class="num" id="LN1110">1110</td><td class="line">			<span class='keyword'>if</span> (!v)</td></tr>
<tr><td class="num" id="LN1111">1111</td><td class="line">				expr = isl_ast_expr_free(expr);</td></tr>
<tr><td class="num" id="LN1112">1112</td><td class="line">			<span class='keyword'>if</span> (isl_val_is_zero(v)) {</td></tr>
<tr><td class="num" id="LN1113">1113</td><td class="line">				isl_val_free(v);</td></tr>
<tr><td class="num" id="LN1114">1114</td><td class="line">				<span class='keyword'>continue</span>;</td></tr>
<tr><td class="num" id="LN1115">1115</td><td class="line">			}</td></tr>
<tr><td class="num" id="LN1116">1116</td><td class="line">			expr = isl_ast_expr_add_term(expr,</td></tr>
<tr><td class="num" id="LN1117">1117</td><td class="line">							ls, l[i], j, v, &amp;data);</td></tr>
<tr><td class="num" id="LN1118">1118</td><td class="line">		}</td></tr>
<tr><td class="num" id="LN1119">1119</td><td class="line">	}</td></tr>
<tr><td class="num" id="LN1120">1120</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1121">1121</td><td class="line">	expr = isl_ast_expr_add_int(expr, data.cst);</td></tr>
<tr><td class="num" id="LN1122">1122</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1123">1123</td><td class="line">	isl_local_space_free(ls);</td></tr>
<tr><td class="num" id="LN1124">1124</td><td class="line">	isl_aff_free(aff);</td></tr>
<tr><td class="num" id="LN1125">1125</td><td class="line">	<span class='keyword'>return</span> expr;</td></tr>
<tr><td class="num" id="LN1126">1126</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1127">1127</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1128">1128</td><td class="line"><span class='comment'>/* Add terms to "expr" for each variable in "aff" with a coefficient</span></td></tr>
<tr><td class="num" id="LN1129">1129</td><td class="line"> <span class='comment'>* with sign equal to "sign".</span></td></tr>
<tr><td class="num" id="LN1130">1130</td><td class="line"> <span class='comment'>* The result is simplified in terms of data-&gt;build-&gt;domain.</span></td></tr>
<tr><td class="num" id="LN1131">1131</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN1132">1132</td><td class="line"><span class='keyword'>static</span> <span class='macro'>__isl_give<span class='expansion'>__attribute__((cf_returns_retained))</span></span> isl_ast_expr *add_signed_terms(<span class='macro'>__isl_take<span class='expansion'>__attribute__((cf_consumed))</span></span> isl_ast_expr *expr,</td></tr>
<tr><td class="num" id="LN1133">1133</td><td class="line">	__isl_keep isl_aff *aff, <span class='keyword'>int</span> sign, <span class='keyword'>struct</span> isl_ast_add_term_data *data)</td></tr>
<tr><td class="num" id="LN1134">1134</td><td class="line">{</td></tr>
<tr><td class="num" id="LN1135">1135</td><td class="line">	<span class='keyword'>int</span> i, j;</td></tr>
<tr><td class="num" id="LN1136">1136</td><td class="line">	isl_val *v;</td></tr>
<tr><td class="num" id="LN1137">1137</td><td class="line">	<span class='keyword'>enum</span> isl_dim_type t[] = { isl_dim_param, isl_dim_in, isl_dim_div };</td></tr>
<tr><td class="num" id="LN1138">1138</td><td class="line">	<span class='keyword'>enum</span> isl_dim_type l[] = { isl_dim_param, isl_dim_set, isl_dim_div };</td></tr>
<tr><td class="num" id="LN1139">1139</td><td class="line">	isl_local_space *ls;</td></tr>
<tr><td class="num" id="LN1140">1140</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1141">1141</td><td class="line">	ls = isl_aff_get_domain_local_space(aff);</td></tr>
<tr><td class="num" id="LN1142">1142</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1143">1143</td><td class="line">	<span class='keyword'>for</span> (i = 0; i &lt; 3; ++i) {</td></tr>
<tr><td class="num" id="LN1144">1144</td><td class="line">		<span class='keyword'>int</span> n = isl_aff_dim(aff, t[i]);</td></tr>
<tr><td class="num" id="LN1145">1145</td><td class="line">		<span class='keyword'>for</span> (j = 0; j &lt; n; ++j) {</td></tr>
<tr><td class="num" id="LN1146">1146</td><td class="line">			v = isl_aff_get_coefficient_val(aff, t[i], j);</td></tr>
<tr><td class="num" id="LN1147">1147</td><td class="line">			<span class='keyword'>if</span> (sign * isl_val_sgn(v) &lt;= 0) {</td></tr>
<tr><td class="num" id="LN1148">1148</td><td class="line">				isl_val_free(v);</td></tr>
<tr><td class="num" id="LN1149">1149</td><td class="line">				<span class='keyword'>continue</span>;</td></tr>
<tr><td class="num" id="LN1150">1150</td><td class="line">			}</td></tr>
<tr><td class="num" id="LN1151">1151</td><td class="line">			v = isl_val_abs(v);</td></tr>
<tr><td class="num" id="LN1152">1152</td><td class="line">			expr = isl_ast_expr_add_term(expr,</td></tr>
<tr><td class="num" id="LN1153">1153</td><td class="line">						ls, l[i], j, v, data);</td></tr>
<tr><td class="num" id="LN1154">1154</td><td class="line">		}</td></tr>
<tr><td class="num" id="LN1155">1155</td><td class="line">	}</td></tr>
<tr><td class="num" id="LN1156">1156</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1157">1157</td><td class="line">	isl_local_space_free(ls);</td></tr>
<tr><td class="num" id="LN1158">1158</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1159">1159</td><td class="line">	<span class='keyword'>return</span> expr;</td></tr>
<tr><td class="num" id="LN1160">1160</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1161">1161</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1162">1162</td><td class="line"><span class='comment'>/* Should the constant term "v" be considered positive?</span></td></tr>
<tr><td class="num" id="LN1163">1163</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN1164">1164</td><td class="line"> <span class='comment'>* A positive constant will be added to "pos" by the caller,</span></td></tr>
<tr><td class="num" id="LN1165">1165</td><td class="line"> <span class='comment'>* while a negative constant will be added to "neg".</span></td></tr>
<tr><td class="num" id="LN1166">1166</td><td class="line"> <span class='comment'>* If either "pos" or "neg" is exactly zero, then we prefer</span></td></tr>
<tr><td class="num" id="LN1167">1167</td><td class="line"> <span class='comment'>* to add the constant "v" to that side, irrespective of the sign of "v".</span></td></tr>
<tr><td class="num" id="LN1168">1168</td><td class="line"> <span class='comment'>* This results in slightly shorter expressions and may reduce the risk</span></td></tr>
<tr><td class="num" id="LN1169">1169</td><td class="line"> <span class='comment'>* of overflows.</span></td></tr>
<tr><td class="num" id="LN1170">1170</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN1171">1171</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>int</span> constant_is_considered_positive(__isl_keep isl_val *v,</td></tr>
<tr><td class="num" id="LN1172">1172</td><td class="line">	__isl_keep isl_ast_expr *pos, __isl_keep isl_ast_expr *neg)</td></tr>
<tr><td class="num" id="LN1173">1173</td><td class="line">{</td></tr>
<tr><td class="num" id="LN1174">1174</td><td class="line">	<span class='keyword'>if</span> (ast_expr_is_zero(pos))</td></tr>
<tr><td class="num" id="LN1175">1175</td><td class="line">		<span class='keyword'>return</span> 1;</td></tr>
<tr><td class="num" id="LN1176">1176</td><td class="line">	<span class='keyword'>if</span> (ast_expr_is_zero(neg))</td></tr>
<tr><td class="num" id="LN1177">1177</td><td class="line">		<span class='keyword'>return</span> 0;</td></tr>
<tr><td class="num" id="LN1178">1178</td><td class="line">	<span class='keyword'>return</span> isl_val_is_pos(v);</td></tr>
<tr><td class="num" id="LN1179">1179</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1180">1180</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1181">1181</td><td class="line"><span class='comment'>/* Check if the equality</span></td></tr>
<tr><td class="num" id="LN1182">1182</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN1183">1183</td><td class="line"> <span class='comment'>*	aff = 0</span></td></tr>
<tr><td class="num" id="LN1184">1184</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN1185">1185</td><td class="line"> <span class='comment'>* represents a stride constraint on the integer division "pos".</span></td></tr>
<tr><td class="num" id="LN1186">1186</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN1187">1187</td><td class="line"> <span class='comment'>* In particular, if the integer division "pos" is equal to</span></td></tr>
<tr><td class="num" id="LN1188">1188</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN1189">1189</td><td class="line"> <span class='comment'>*	floor(e/d)</span></td></tr>
<tr><td class="num" id="LN1190">1190</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN1191">1191</td><td class="line"> <span class='comment'>* then check if aff is equal to</span></td></tr>
<tr><td class="num" id="LN1192">1192</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN1193">1193</td><td class="line"> <span class='comment'>*	e - d floor(e/d)</span></td></tr>
<tr><td class="num" id="LN1194">1194</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN1195">1195</td><td class="line"> <span class='comment'>* or its opposite.</span></td></tr>
<tr><td class="num" id="LN1196">1196</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN1197">1197</td><td class="line"> <span class='comment'>* If so, the equality is exactly</span></td></tr>
<tr><td class="num" id="LN1198">1198</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN1199">1199</td><td class="line"> <span class='comment'>*	e mod d = 0</span></td></tr>
<tr><td class="num" id="LN1200">1200</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN1201">1201</td><td class="line"> <span class='comment'>* Note that in principle we could also accept</span></td></tr>
<tr><td class="num" id="LN1202">1202</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN1203">1203</td><td class="line"> <span class='comment'>*	e - d floor(e'/d)</span></td></tr>
<tr><td class="num" id="LN1204">1204</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN1205">1205</td><td class="line"> <span class='comment'>* where e and e' differ by a constant.</span></td></tr>
<tr><td class="num" id="LN1206">1206</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN1207">1207</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>int</span> is_stride_constraint(__isl_keep isl_aff *aff, <span class='keyword'>int</span> pos)</td></tr>
<tr><td class="num" id="LN1208">1208</td><td class="line">{</td></tr>
<tr><td class="num" id="LN1209">1209</td><td class="line">	isl_aff *div;</td></tr>
<tr><td class="num" id="LN1210">1210</td><td class="line">	isl_val *c, *d;</td></tr>
<tr><td class="num" id="LN1211">1211</td><td class="line">	<span class='keyword'>int</span> eq;</td></tr>
<tr><td class="num" id="LN1212">1212</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1213">1213</td><td class="line">	div = isl_aff_get_div(aff, pos);</td></tr>
<tr><td class="num" id="LN1214">1214</td><td class="line">	c = isl_aff_get_coefficient_val(aff, isl_dim_div, pos);</td></tr>
<tr><td class="num" id="LN1215">1215</td><td class="line">	d = isl_aff_get_denominator_val(div);</td></tr>
<tr><td class="num" id="LN1216">1216</td><td class="line">	eq = isl_val_abs_eq(c, d);</td></tr>
<tr><td class="num" id="LN1217">1217</td><td class="line">	<span class='keyword'>if</span> (eq &gt;= 0 &amp;&amp; eq) {</td></tr>
<tr><td class="num" id="LN1218">1218</td><td class="line">		aff = isl_aff_copy(aff);</td></tr>
<tr><td class="num" id="LN1219">1219</td><td class="line">		aff = isl_aff_set_coefficient_si(aff, isl_dim_div, pos, 0);</td></tr>
<tr><td class="num" id="LN1220">1220</td><td class="line">		div = isl_aff_scale_val(div, d);</td></tr>
<tr><td class="num" id="LN1221">1221</td><td class="line">		<span class='keyword'>if</span> (isl_val_is_pos(c))</td></tr>
<tr><td class="num" id="LN1222">1222</td><td class="line">			div = isl_aff_neg(div);</td></tr>
<tr><td class="num" id="LN1223">1223</td><td class="line">		eq = isl_aff_plain_is_equal(div, aff);</td></tr>
<tr><td class="num" id="LN1224">1224</td><td class="line">		isl_aff_free(aff);</td></tr>
<tr><td class="num" id="LN1225">1225</td><td class="line">	} <span class='keyword'>else</span></td></tr>
<tr><td class="num" id="LN1226">1226</td><td class="line">		isl_val_free(d);</td></tr>
<tr><td class="num" id="LN1227">1227</td><td class="line">	isl_val_free(c);</td></tr>
<tr><td class="num" id="LN1228">1228</td><td class="line">	isl_aff_free(div);</td></tr>
<tr><td class="num" id="LN1229">1229</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1230">1230</td><td class="line">	<span class='keyword'>return</span> eq;</td></tr>
<tr><td class="num" id="LN1231">1231</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1232">1232</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1233">1233</td><td class="line"><span class='comment'>/* Are all coefficients of "aff" (zero or) negative?</span></td></tr>
<tr><td class="num" id="LN1234">1234</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN1235">1235</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>int</span> all_negative_coefficients(__isl_keep isl_aff *aff)</td></tr>
<tr><td class="num" id="LN1236">1236</td><td class="line">{</td></tr>
<tr><td class="num" id="LN1237">1237</td><td class="line">	<span class='keyword'>int</span> i, n;</td></tr>
<tr><td class="num" id="LN1238">1238</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1239">1239</td><td class="line">	<span class='keyword'>if</span> (!aff)</td></tr>
<tr><td class="num" id="LN1240">1240</td><td class="line">		<span class='keyword'>return</span> 0;</td></tr>
<tr><td class="num" id="LN1241">1241</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1242">1242</td><td class="line">	n = isl_aff_dim(aff, isl_dim_param);</td></tr>
<tr><td class="num" id="LN1243">1243</td><td class="line">	<span class='keyword'>for</span> (i = 0; i &lt; n; ++i)</td></tr>
<tr><td class="num" id="LN1244">1244</td><td class="line">		<span class='keyword'>if</span> (isl_aff_coefficient_sgn(aff, isl_dim_param, i) &gt; 0)</td></tr>
<tr><td class="num" id="LN1245">1245</td><td class="line">			<span class='keyword'>return</span> 0;</td></tr>
<tr><td class="num" id="LN1246">1246</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1247">1247</td><td class="line">	n = isl_aff_dim(aff, isl_dim_in);</td></tr>
<tr><td class="num" id="LN1248">1248</td><td class="line">	<span class='keyword'>for</span> (i = 0; i &lt; n; ++i)</td></tr>
<tr><td class="num" id="LN1249">1249</td><td class="line">		<span class='keyword'>if</span> (isl_aff_coefficient_sgn(aff, isl_dim_in, i) &gt; 0)</td></tr>
<tr><td class="num" id="LN1250">1250</td><td class="line">			<span class='keyword'>return</span> 0;</td></tr>
<tr><td class="num" id="LN1251">1251</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1252">1252</td><td class="line">	<span class='keyword'>return</span> 1;</td></tr>
<tr><td class="num" id="LN1253">1253</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1254">1254</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1255">1255</td><td class="line"><span class='comment'>/* Give an equality of the form</span></td></tr>
<tr><td class="num" id="LN1256">1256</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN1257">1257</td><td class="line"> <span class='comment'>*	aff = e - d floor(e/d) = 0</span></td></tr>
<tr><td class="num" id="LN1258">1258</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN1259">1259</td><td class="line"> <span class='comment'>* or</span></td></tr>
<tr><td class="num" id="LN1260">1260</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN1261">1261</td><td class="line"> <span class='comment'>*	aff = -e + d floor(e/d) = 0</span></td></tr>
<tr><td class="num" id="LN1262">1262</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN1263">1263</td><td class="line"> <span class='comment'>* with the integer division "pos" equal to floor(e/d),</span></td></tr>
<tr><td class="num" id="LN1264">1264</td><td class="line"> <span class='comment'>* construct the AST expression</span></td></tr>
<tr><td class="num" id="LN1265">1265</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN1266">1266</td><td class="line"> <span class='comment'>*	(isl_ast_op_eq, (isl_ast_op_zdiv_r, expr(e), expr(d)), expr(0))</span></td></tr>
<tr><td class="num" id="LN1267">1267</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN1268">1268</td><td class="line"> <span class='comment'>* If e only has negative coefficients, then construct</span></td></tr>
<tr><td class="num" id="LN1269">1269</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN1270">1270</td><td class="line"> <span class='comment'>*	(isl_ast_op_eq, (isl_ast_op_zdiv_r, expr(-e), expr(d)), expr(0))</span></td></tr>
<tr><td class="num" id="LN1271">1271</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN1272">1272</td><td class="line"> <span class='comment'>* instead.</span></td></tr>
<tr><td class="num" id="LN1273">1273</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN1274">1274</td><td class="line"><span class='keyword'>static</span> <span class='macro'>__isl_give<span class='expansion'>__attribute__((cf_returns_retained))</span></span> isl_ast_expr *extract_stride_constraint(</td></tr>
<tr><td class="num" id="LN1275">1275</td><td class="line">	<span class='macro'>__isl_take<span class='expansion'>__attribute__((cf_consumed))</span></span> isl_aff *aff, <span class='keyword'>int</span> pos, __isl_keep isl_ast_build *build)</td></tr>
<tr><td class="num" id="LN1276">1276</td><td class="line">{</td></tr>
<tr><td class="num" id="LN1277">1277</td><td class="line">	isl_ctx *ctx;</td></tr>
<tr><td class="num" id="LN1278">1278</td><td class="line">	isl_val *c;</td></tr>
<tr><td class="num" id="LN1279">1279</td><td class="line">	isl_ast_expr *expr, *cst;</td></tr>
<tr><td class="num" id="LN1280">1280</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1281">1281</td><td class="line">	<span class='keyword'>if</span> (!aff)</td></tr>
<tr><td class="num" id="LN1282">1282</td><td class="line">		<span class='keyword'>return</span> <span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;</td></tr>
<tr><td class="num" id="LN1283">1283</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1284">1284</td><td class="line">	ctx = isl_aff_get_ctx(aff);</td></tr>
<tr><td class="num" id="LN1285">1285</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1286">1286</td><td class="line">	c = isl_aff_get_coefficient_val(aff, isl_dim_div, pos);</td></tr>
<tr><td class="num" id="LN1287">1287</td><td class="line">	aff = isl_aff_set_coefficient_si(aff, isl_dim_div, pos, 0);</td></tr>
<tr><td class="num" id="LN1288">1288</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1289">1289</td><td class="line">	<span class='keyword'>if</span> (all_negative_coefficients(aff))</td></tr>
<tr><td class="num" id="LN1290">1290</td><td class="line">		aff = isl_aff_neg(aff);</td></tr>
<tr><td class="num" id="LN1291">1291</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1292">1292</td><td class="line">	cst = isl_ast_expr_from_val(isl_val_abs(c));</td></tr>
<tr><td class="num" id="LN1293">1293</td><td class="line">	expr = isl_ast_expr_from_aff(aff, build);</td></tr>
<tr><td class="num" id="LN1294">1294</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1295">1295</td><td class="line">	expr = isl_ast_expr_alloc_binary(isl_ast_op_zdiv_r, expr, cst);</td></tr>
<tr><td class="num" id="LN1296">1296</td><td class="line">	cst = isl_ast_expr_alloc_int_si(ctx, 0);</td></tr>
<tr><td class="num" id="LN1297">1297</td><td class="line">	expr = isl_ast_expr_alloc_binary(isl_ast_op_eq, expr, cst);</td></tr>
<tr><td class="num" id="LN1298">1298</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1299">1299</td><td class="line">	<span class='keyword'>return</span> expr;</td></tr>
<tr><td class="num" id="LN1300">1300</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1301">1301</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1302">1302</td><td class="line"><span class='comment'>/* Construct an isl_ast_expr that evaluates the condition "constraint",</span></td></tr>
<tr><td class="num" id="LN1303">1303</td><td class="line"> <span class='comment'>* The result is simplified in terms of build-&gt;domain.</span></td></tr>
<tr><td class="num" id="LN1304">1304</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN1305">1305</td><td class="line"> <span class='comment'>* We first check if the constraint is an equality of the form</span></td></tr>
<tr><td class="num" id="LN1306">1306</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN1307">1307</td><td class="line"> <span class='comment'>*	e - d floor(e/d) = 0</span></td></tr>
<tr><td class="num" id="LN1308">1308</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN1309">1309</td><td class="line"> <span class='comment'>* i.e.,</span></td></tr>
<tr><td class="num" id="LN1310">1310</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN1311">1311</td><td class="line"> <span class='comment'>*	e mod d = 0</span></td></tr>
<tr><td class="num" id="LN1312">1312</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN1313">1313</td><td class="line"> <span class='comment'>* If so, we convert it to</span></td></tr>
<tr><td class="num" id="LN1314">1314</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN1315">1315</td><td class="line"> <span class='comment'>*	(isl_ast_op_eq, (isl_ast_op_zdiv_r, expr(e), expr(d)), expr(0))</span></td></tr>
<tr><td class="num" id="LN1316">1316</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN1317">1317</td><td class="line"> <span class='comment'>* Otherwise, let the constraint by either "a &gt;= 0" or "a == 0".</span></td></tr>
<tr><td class="num" id="LN1318">1318</td><td class="line"> <span class='comment'>* We first extract hidden modulo computations from "a"</span></td></tr>
<tr><td class="num" id="LN1319">1319</td><td class="line"> <span class='comment'>* and then collect all the terms with a positive coefficient in cons_pos</span></td></tr>
<tr><td class="num" id="LN1320">1320</td><td class="line"> <span class='comment'>* and the terms with a negative coefficient in cons_neg.</span></td></tr>
<tr><td class="num" id="LN1321">1321</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN1322">1322</td><td class="line"> <span class='comment'>* The result is then of the form</span></td></tr>
<tr><td class="num" id="LN1323">1323</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN1324">1324</td><td class="line"> <span class='comment'>*	(isl_ast_op_ge, expr(pos), expr(-neg)))</span></td></tr>
<tr><td class="num" id="LN1325">1325</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN1326">1326</td><td class="line"> <span class='comment'>* or</span></td></tr>
<tr><td class="num" id="LN1327">1327</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN1328">1328</td><td class="line"> <span class='comment'>*	(isl_ast_op_eq, expr(pos), expr(-neg)))</span></td></tr>
<tr><td class="num" id="LN1329">1329</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN1330">1330</td><td class="line"> <span class='comment'>* However, if the first expression is an integer constant (and the second</span></td></tr>
<tr><td class="num" id="LN1331">1331</td><td class="line"> <span class='comment'>* is not), then we swap the two expressions.  This ensures that we construct,</span></td></tr>
<tr><td class="num" id="LN1332">1332</td><td class="line"> <span class='comment'>* e.g., "i &lt;= 5" rather than "5 &gt;= i".</span></td></tr>
<tr><td class="num" id="LN1333">1333</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN1334">1334</td><td class="line"> <span class='comment'>* Furthermore, is there are no terms with positive coefficients (or no terms</span></td></tr>
<tr><td class="num" id="LN1335">1335</td><td class="line"> <span class='comment'>* with negative coefficients), then the constant term is added to "pos"</span></td></tr>
<tr><td class="num" id="LN1336">1336</td><td class="line"> <span class='comment'>* (or "neg"), ignoring the sign of the constant term.</span></td></tr>
<tr><td class="num" id="LN1337">1337</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN1338">1338</td><td class="line"><span class='keyword'>static</span> <span class='macro'>__isl_give<span class='expansion'>__attribute__((cf_returns_retained))</span></span> isl_ast_expr *isl_ast_expr_from_constraint(</td></tr>
<tr><td class="num" id="LN1339">1339</td><td class="line">	<span class='macro'>__isl_take<span class='expansion'>__attribute__((cf_consumed))</span></span> isl_constraint *constraint, __isl_keep isl_ast_build *build)</td></tr>
<tr><td class="num" id="LN1340">1340</td><td class="line">{</td></tr>
<tr><td class="num" id="LN1341">1341</td><td class="line">	<span class='keyword'>int</span> i, n;</td></tr>
<tr><td class="num" id="LN1342">1342</td><td class="line">	isl_ctx *ctx;</td></tr>
<tr><td class="num" id="LN1343">1343</td><td class="line">	isl_ast_expr *expr_pos;</td></tr>
<tr><td class="num" id="LN1344">1344</td><td class="line">	isl_ast_expr *expr_neg;</td></tr>
<tr><td class="num" id="LN1345">1345</td><td class="line">	isl_ast_expr *expr;</td></tr>
<tr><td class="num" id="LN1346">1346</td><td class="line">	isl_aff *aff;</td></tr>
<tr><td class="num" id="LN1347">1347</td><td class="line">	<span class='keyword'>int</span> eq;</td></tr>
<tr><td class="num" id="LN1348">1348</td><td class="line">	<span class='keyword'>enum</span> isl_ast_op_type type;</td></tr>
<tr><td class="num" id="LN1349">1349</td><td class="line">	<span class='keyword'>struct</span> isl_ast_add_term_data data;</td></tr>
<tr><td class="num" id="LN1350">1350</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1351">1351</td><td class="line">	<span class='keyword'>if</span> (!constraint)</td></tr>
<tr><td class="num" id="LN1352">1352</td><td class="line">		<span class='keyword'>return</span> <span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;</td></tr>
<tr><td class="num" id="LN1353">1353</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1354">1354</td><td class="line">	aff = isl_constraint_get_aff(constraint);</td></tr>
<tr><td class="num" id="LN1355">1355</td><td class="line">	eq = isl_constraint_is_equality(constraint);</td></tr>
<tr><td class="num" id="LN1356">1356</td><td class="line">	isl_constraint_free(constraint);</td></tr>
<tr><td class="num" id="LN1357">1357</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1358">1358</td><td class="line">	n = isl_aff_dim(aff, isl_dim_div);</td></tr>
<tr><td class="num" id="LN1359">1359</td><td class="line">	<span class='keyword'>if</span> (eq &amp;&amp; n &gt; 0)</td></tr>
<tr><td class="num" id="LN1360">1360</td><td class="line">		<span class='keyword'>for</span> (i = 0; i &lt; n; ++i) {</td></tr>
<tr><td class="num" id="LN1361">1361</td><td class="line">			<span class='keyword'>int</span> is_stride;</td></tr>
<tr><td class="num" id="LN1362">1362</td><td class="line">			is_stride = is_stride_constraint(aff, i);</td></tr>
<tr><td class="num" id="LN1363">1363</td><td class="line">			<span class='keyword'>if</span> (is_stride &lt; 0)</td></tr>
<tr><td class="num" id="LN1364">1364</td><td class="line">				<span class='keyword'>goto</span> error;</td></tr>
<tr><td class="num" id="LN1365">1365</td><td class="line">			<span class='keyword'>if</span> (is_stride)</td></tr>
<tr><td class="num" id="LN1366">1366</td><td class="line">				<span class='keyword'>return</span> extract_stride_constraint(aff, i, build);</td></tr>
<tr><td class="num" id="LN1367">1367</td><td class="line">		}</td></tr>
<tr><td class="num" id="LN1368">1368</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1369">1369</td><td class="line">	ctx = isl_aff_get_ctx(aff);</td></tr>
<tr><td class="num" id="LN1370">1370</td><td class="line">	expr_pos = isl_ast_expr_alloc_int_si(ctx, 0);</td></tr>
<tr><td class="num" id="LN1371">1371</td><td class="line">	expr_neg = isl_ast_expr_alloc_int_si(ctx, 0);</td></tr>
<tr><td class="num" id="LN1372">1372</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1373">1373</td><td class="line">	aff = extract_modulos(aff, &amp;expr_pos, &amp;expr_neg, build);</td></tr>
<tr><td class="num" id="LN1374">1374</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1375">1375</td><td class="line">	data.build = build;</td></tr>
<tr><td class="num" id="LN1376">1376</td><td class="line">	data.cst = isl_aff_get_constant_val(aff);</td></tr>
<tr><td class="num" id="LN1377">1377</td><td class="line">	expr_pos = add_signed_terms(expr_pos, aff, 1, &amp;data);</td></tr>
<tr><td class="num" id="LN1378">1378</td><td class="line">	data.cst = isl_val_neg(data.cst);</td></tr>
<tr><td class="num" id="LN1379">1379</td><td class="line">	expr_neg = add_signed_terms(expr_neg, aff, -1, &amp;data);</td></tr>
<tr><td class="num" id="LN1380">1380</td><td class="line">	data.cst = isl_val_neg(data.cst);</td></tr>
<tr><td class="num" id="LN1381">1381</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1382">1382</td><td class="line">	<span class='keyword'>if</span> (constant_is_considered_positive(data.cst, expr_pos, expr_neg)) {</td></tr>
<tr><td class="num" id="LN1383">1383</td><td class="line">		expr_pos = isl_ast_expr_add_int(expr_pos, data.cst);</td></tr>
<tr><td class="num" id="LN1384">1384</td><td class="line">	} <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN1385">1385</td><td class="line">		data.cst = isl_val_neg(data.cst);</td></tr>
<tr><td class="num" id="LN1386">1386</td><td class="line">		expr_neg = isl_ast_expr_add_int(expr_neg, data.cst);</td></tr>
<tr><td class="num" id="LN1387">1387</td><td class="line">	}</td></tr>
<tr><td class="num" id="LN1388">1388</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1389">1389</td><td class="line">	<span class='keyword'>if</span> (isl_ast_expr_get_type(expr_pos) == isl_ast_expr_int &amp;&amp;</td></tr>
<tr><td class="num" id="LN1390">1390</td><td class="line">	    isl_ast_expr_get_type(expr_neg) != isl_ast_expr_int) {</td></tr>
<tr><td class="num" id="LN1391">1391</td><td class="line">		type = eq ? isl_ast_op_eq : isl_ast_op_le;</td></tr>
<tr><td class="num" id="LN1392">1392</td><td class="line">		expr = isl_ast_expr_alloc_binary(type, expr_neg, expr_pos);</td></tr>
<tr><td class="num" id="LN1393">1393</td><td class="line">	} <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN1394">1394</td><td class="line">		type = eq ? isl_ast_op_eq : isl_ast_op_ge;</td></tr>
<tr><td class="num" id="LN1395">1395</td><td class="line">		expr = isl_ast_expr_alloc_binary(type, expr_pos, expr_neg);</td></tr>
<tr><td class="num" id="LN1396">1396</td><td class="line">	}</td></tr>
<tr><td class="num" id="LN1397">1397</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1398">1398</td><td class="line">	isl_aff_free(aff);</td></tr>
<tr><td class="num" id="LN1399">1399</td><td class="line">	<span class='keyword'>return</span> expr;</td></tr>
<tr><td class="num" id="LN1400">1400</td><td class="line">error:</td></tr>
<tr><td class="num" id="LN1401">1401</td><td class="line">	isl_aff_free(aff);</td></tr>
<tr><td class="num" id="LN1402">1402</td><td class="line">	<span class='keyword'>return</span> <span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;</td></tr>
<tr><td class="num" id="LN1403">1403</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1404">1404</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1405">1405</td><td class="line"><span class='comment'>/* Wrapper around isl_constraint_cmp_last_non_zero for use</span></td></tr>
<tr><td class="num" id="LN1406">1406</td><td class="line"> <span class='comment'>* as a callback to isl_constraint_list_sort.</span></td></tr>
<tr><td class="num" id="LN1407">1407</td><td class="line"> <span class='comment'>* If isl_constraint_cmp_last_non_zero cannot tell the constraints</span></td></tr>
<tr><td class="num" id="LN1408">1408</td><td class="line"> <span class='comment'>* apart, then use isl_constraint_plain_cmp instead.</span></td></tr>
<tr><td class="num" id="LN1409">1409</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN1410">1410</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>int</span> cmp_constraint(__isl_keep isl_constraint *a,</td></tr>
<tr><td class="num" id="LN1411">1411</td><td class="line">	__isl_keep isl_constraint *b, <span class='keyword'>void</span> *user)</td></tr>
<tr><td class="num" id="LN1412">1412</td><td class="line">{</td></tr>
<tr><td class="num" id="LN1413">1413</td><td class="line">	<span class='keyword'>int</span> cmp;</td></tr>
<tr><td class="num" id="LN1414">1414</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1415">1415</td><td class="line">	cmp = isl_constraint_cmp_last_non_zero(a, b);</td></tr>
<tr><td class="num" id="LN1416">1416</td><td class="line">	<span class='keyword'>if</span> (cmp != 0)</td></tr>
<tr><td class="num" id="LN1417">1417</td><td class="line">		<span class='keyword'>return</span> cmp;</td></tr>
<tr><td class="num" id="LN1418">1418</td><td class="line">	<span class='keyword'>return</span> isl_constraint_plain_cmp(a, b);</td></tr>
<tr><td class="num" id="LN1419">1419</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1420">1420</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1421">1421</td><td class="line"><span class='comment'>/* Construct an isl_ast_expr that evaluates the conditions defining "bset".</span></td></tr>
<tr><td class="num" id="LN1422">1422</td><td class="line"> <span class='comment'>* The result is simplified in terms of build-&gt;domain.</span></td></tr>
<tr><td class="num" id="LN1423">1423</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN1424">1424</td><td class="line"> <span class='comment'>* If "bset" is not bounded by any constraint, then we contruct</span></td></tr>
<tr><td class="num" id="LN1425">1425</td><td class="line"> <span class='comment'>* the expression "1", i.e., "true".</span></td></tr>
<tr><td class="num" id="LN1426">1426</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN1427">1427</td><td class="line"> <span class='comment'>* Otherwise, we sort the constraints, putting constraints that involve</span></td></tr>
<tr><td class="num" id="LN1428">1428</td><td class="line"> <span class='comment'>* integer divisions after those that do not, and construct an "and"</span></td></tr>
<tr><td class="num" id="LN1429">1429</td><td class="line"> <span class='comment'>* of the ast expressions of the individual constraints.</span></td></tr>
<tr><td class="num" id="LN1430">1430</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN1431">1431</td><td class="line"> <span class='comment'>* Each constraint is added to the generated constraints of the build</span></td></tr>
<tr><td class="num" id="LN1432">1432</td><td class="line"> <span class='comment'>* after it has been converted to an AST expression so that it can be used</span></td></tr>
<tr><td class="num" id="LN1433">1433</td><td class="line"> <span class='comment'>* to simplify the following constraints.  This may change the truth value</span></td></tr>
<tr><td class="num" id="LN1434">1434</td><td class="line"> <span class='comment'>* of subsequent constraints that do not satisfy the earlier constraints,</span></td></tr>
<tr><td class="num" id="LN1435">1435</td><td class="line"> <span class='comment'>* but this does not affect the outcome of the conjunction as it is</span></td></tr>
<tr><td class="num" id="LN1436">1436</td><td class="line"> <span class='comment'>* only true if all the conjuncts are true (no matter in what order</span></td></tr>
<tr><td class="num" id="LN1437">1437</td><td class="line"> <span class='comment'>* they are evaluated).  In particular, the constraints that do not</span></td></tr>
<tr><td class="num" id="LN1438">1438</td><td class="line"> <span class='comment'>* involve integer divisions may serve to simplify some constraints</span></td></tr>
<tr><td class="num" id="LN1439">1439</td><td class="line"> <span class='comment'>* that do involve integer divisions.</span></td></tr>
<tr><td class="num" id="LN1440">1440</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN1441">1441</td><td class="line"><span class='macro'>__isl_give<span class='expansion'>__attribute__((cf_returns_retained))</span></span> isl_ast_expr *isl_ast_build_expr_from_basic_set(</td></tr>
<tr><td class="num" id="LN1442">1442</td><td class="line">	 __isl_keep isl_ast_build *build, <span class='macro'>__isl_take<span class='expansion'>__attribute__((cf_consumed))</span></span> isl_basic_set *bset)</td></tr>
<tr><td class="num" id="LN1443">1443</td><td class="line">{</td></tr>
<tr><td class="num" id="LN1444">1444</td><td class="line">	<span class='keyword'>int</span> i, n;</td></tr>
<tr><td class="num" id="LN1445">1445</td><td class="line">	isl_constraint *c;</td></tr>
<tr><td class="num" id="LN1446">1446</td><td class="line">	isl_constraint_list *list;</td></tr>
<tr><td class="num" id="LN1447">1447</td><td class="line">	isl_ast_expr *res;</td></tr>
<tr><td class="num" id="LN1448">1448</td><td class="line">	isl_set *set;</td></tr>
<tr><td class="num" id="LN1449">1449</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1450">1450</td><td class="line">	list = isl_basic_set_get_constraint_list(bset);</td></tr>
<tr><td class="num" id="LN1451">1451</td><td class="line">	isl_basic_set_free(bset);</td></tr>
<tr><td class="num" id="LN1452">1452</td><td class="line">	list = isl_constraint_list_sort(list, &amp;cmp_constraint, <span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>);</td></tr>
<tr><td class="num" id="LN1453">1453</td><td class="line">	<span class='keyword'>if</span> (!list)</td></tr>
<tr><td class="num" id="LN1454">1454</td><td class="line">		<span class='keyword'>return</span> <span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;</td></tr>
<tr><td class="num" id="LN1455">1455</td><td class="line">	n = isl_constraint_list_n_constraint(list);</td></tr>
<tr><td class="num" id="LN1456">1456</td><td class="line">	<span class='keyword'>if</span> (n == 0) {</td></tr>
<tr><td class="num" id="LN1457">1457</td><td class="line">		isl_ctx *ctx = isl_constraint_list_get_ctx(list);</td></tr>
<tr><td class="num" id="LN1458">1458</td><td class="line">		isl_constraint_list_free(list);</td></tr>
<tr><td class="num" id="LN1459">1459</td><td class="line">		<span class='keyword'>return</span> isl_ast_expr_alloc_int_si(ctx, 1);</td></tr>
<tr><td class="num" id="LN1460">1460</td><td class="line">	}</td></tr>
<tr><td class="num" id="LN1461">1461</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1462">1462</td><td class="line">	build = isl_ast_build_copy(build);</td></tr>
<tr><td class="num" id="LN1463">1463</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1464">1464</td><td class="line">	c = isl_constraint_list_get_constraint(list, 0);</td></tr>
<tr><td class="num" id="LN1465">1465</td><td class="line">	bset = isl_basic_set_from_constraint(isl_constraint_copy(c));</td></tr>
<tr><td class="num" id="LN1466">1466</td><td class="line">	set = isl_set_from_basic_set(bset);</td></tr>
<tr><td class="num" id="LN1467">1467</td><td class="line">	res = isl_ast_expr_from_constraint(c, build);</td></tr>
<tr><td class="num" id="LN1468">1468</td><td class="line">	build = isl_ast_build_restrict_generated(build, set);</td></tr>
<tr><td class="num" id="LN1469">1469</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1470">1470</td><td class="line">	<span class='keyword'>for</span> (i = 1; i &lt; n; ++i) {</td></tr>
<tr><td class="num" id="LN1471">1471</td><td class="line">		isl_ast_expr *expr;</td></tr>
<tr><td class="num" id="LN1472">1472</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1473">1473</td><td class="line">		c = isl_constraint_list_get_constraint(list, i);</td></tr>
<tr><td class="num" id="LN1474">1474</td><td class="line">		bset = isl_basic_set_from_constraint(isl_constraint_copy(c));</td></tr>
<tr><td class="num" id="LN1475">1475</td><td class="line">		set = isl_set_from_basic_set(bset);</td></tr>
<tr><td class="num" id="LN1476">1476</td><td class="line">		expr = isl_ast_expr_from_constraint(c, build);</td></tr>
<tr><td class="num" id="LN1477">1477</td><td class="line">		build = isl_ast_build_restrict_generated(build, set);</td></tr>
<tr><td class="num" id="LN1478">1478</td><td class="line">		res = isl_ast_expr_and(res, expr);</td></tr>
<tr><td class="num" id="LN1479">1479</td><td class="line">	}</td></tr>
<tr><td class="num" id="LN1480">1480</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1481">1481</td><td class="line">	isl_constraint_list_free(list);</td></tr>
<tr><td class="num" id="LN1482">1482</td><td class="line">	isl_ast_build_free(build);</td></tr>
<tr><td class="num" id="LN1483">1483</td><td class="line">	<span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN1484">1484</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1485">1485</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1486">1486</td><td class="line"><span class='comment'>/* Construct an isl_ast_expr that evaluates the conditions defining "set".</span></td></tr>
<tr><td class="num" id="LN1487">1487</td><td class="line"> <span class='comment'>* The result is simplified in terms of build-&gt;domain.</span></td></tr>
<tr><td class="num" id="LN1488">1488</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN1489">1489</td><td class="line"> <span class='comment'>* If "set" is an (obviously) empty set, then return the expression "0".</span></td></tr>
<tr><td class="num" id="LN1490">1490</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN1491">1491</td><td class="line"> <span class='comment'>* If there are multiple disjuncts in the description of the set,</span></td></tr>
<tr><td class="num" id="LN1492">1492</td><td class="line"> <span class='comment'>* then subsequent disjuncts are simplified in a context where</span></td></tr>
<tr><td class="num" id="LN1493">1493</td><td class="line"> <span class='comment'>* the previous disjuncts have been removed from build-&gt;domain.</span></td></tr>
<tr><td class="num" id="LN1494">1494</td><td class="line"> <span class='comment'>* In particular, constraints that ensure that there is no overlap</span></td></tr>
<tr><td class="num" id="LN1495">1495</td><td class="line"> <span class='comment'>* with these previous disjuncts, can be removed.</span></td></tr>
<tr><td class="num" id="LN1496">1496</td><td class="line"> <span class='comment'>* This is mostly useful for disjuncts that are only defined by</span></td></tr>
<tr><td class="num" id="LN1497">1497</td><td class="line"> <span class='comment'>* a single constraint (relative to the build domain) as the opposite</span></td></tr>
<tr><td class="num" id="LN1498">1498</td><td class="line"> <span class='comment'>* of that single constraint can then be removed from the other disjuncts.</span></td></tr>
<tr><td class="num" id="LN1499">1499</td><td class="line"> <span class='comment'>* In order not to increase the number of disjuncts in the build domain</span></td></tr>
<tr><td class="num" id="LN1500">1500</td><td class="line"> <span class='comment'>* after subtracting the previous disjuncts of "set", the simple hull</span></td></tr>
<tr><td class="num" id="LN1501">1501</td><td class="line"> <span class='comment'>* is computed after taking the difference with each of these disjuncts.</span></td></tr>
<tr><td class="num" id="LN1502">1502</td><td class="line"> <span class='comment'>* This means that constraints that prevent overlap with a union</span></td></tr>
<tr><td class="num" id="LN1503">1503</td><td class="line"> <span class='comment'>* of multiple previous disjuncts are not removed.</span></td></tr>
<tr><td class="num" id="LN1504">1504</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN1505">1505</td><td class="line"> <span class='comment'>* "set" lives in the internal schedule space.</span></td></tr>
<tr><td class="num" id="LN1506">1506</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN1507">1507</td><td class="line"><span class='macro'>__isl_give<span class='expansion'>__attribute__((cf_returns_retained))</span></span> isl_ast_expr *isl_ast_build_expr_from_set_internal(</td></tr>
<tr><td class="num" id="LN1508">1508</td><td class="line">	__isl_keep isl_ast_build *build, <span class='macro'>__isl_take<span class='expansion'>__attribute__((cf_consumed))</span></span> isl_set *set)</td></tr>
<tr><td class="num" id="LN1509">1509</td><td class="line">{</td></tr>
<tr><td class="num" id="LN1510">1510</td><td class="line">	<span class='keyword'>int</span> i, n;</td></tr>
<tr><td class="num" id="LN1511">1511</td><td class="line">	isl_basic_set *bset;</td></tr>
<tr><td class="num" id="LN1512">1512</td><td class="line">	isl_basic_set_list *list;</td></tr>
<tr><td class="num" id="LN1513">1513</td><td class="line">	isl_set *domain;</td></tr>
<tr><td class="num" id="LN1514">1514</td><td class="line">	isl_ast_expr *res;</td></tr>
<tr><td class="num" id="LN1515">1515</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1516">1516</td><td class="line">	list = isl_set_get_basic_set_list(set);</td></tr>
<tr><td class="num" id="LN1517">1517</td><td class="line">	isl_set_free(set);</td></tr>
<tr><td class="num" id="LN1518">1518</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1519">1519</td><td class="line">	<span class='keyword'>if</span> (!list)</td></tr>
<tr><td class="num" id="LN1520">1520</td><td class="line">		<span class='keyword'>return</span> <span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;</td></tr>
<tr><td class="num" id="LN1521">1521</td><td class="line">	n = isl_basic_set_list_n_basic_set(list);</td></tr>
<tr><td class="num" id="LN1522">1522</td><td class="line">	<span class='keyword'>if</span> (n == 0) {</td></tr>
<tr><td class="num" id="LN1523">1523</td><td class="line">		isl_ctx *ctx = isl_ast_build_get_ctx(build);</td></tr>
<tr><td class="num" id="LN1524">1524</td><td class="line">		isl_basic_set_list_free(list);</td></tr>
<tr><td class="num" id="LN1525">1525</td><td class="line">		<span class='keyword'>return</span> isl_ast_expr_from_val(isl_val_zero(ctx));</td></tr>
<tr><td class="num" id="LN1526">1526</td><td class="line">	}</td></tr>
<tr><td class="num" id="LN1527">1527</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1528">1528</td><td class="line">	domain = isl_ast_build_get_domain(build);</td></tr>
<tr><td class="num" id="LN1529">1529</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1530">1530</td><td class="line">	bset = isl_basic_set_list_get_basic_set(list, 0);</td></tr>
<tr><td class="num" id="LN1531">1531</td><td class="line">	set = isl_set_from_basic_set(isl_basic_set_copy(bset));</td></tr>
<tr><td class="num" id="LN1532">1532</td><td class="line">	res = isl_ast_build_expr_from_basic_set(build, bset);</td></tr>
<tr><td class="num" id="LN1533">1533</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1534">1534</td><td class="line">	<span class='keyword'>for</span> (i = 1; i &lt; n; ++i) {</td></tr>
<tr><td class="num" id="LN1535">1535</td><td class="line">		isl_ast_expr *expr;</td></tr>
<tr><td class="num" id="LN1536">1536</td><td class="line">		isl_set *rest;</td></tr>
<tr><td class="num" id="LN1537">1537</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1538">1538</td><td class="line">		rest = isl_set_subtract(isl_set_copy(domain), set);</td></tr>
<tr><td class="num" id="LN1539">1539</td><td class="line">		rest = isl_set_from_basic_set(isl_set_simple_hull(rest));</td></tr>
<tr><td class="num" id="LN1540">1540</td><td class="line">		domain = isl_set_intersect(domain, rest);</td></tr>
<tr><td class="num" id="LN1541">1541</td><td class="line">		bset = isl_basic_set_list_get_basic_set(list, i);</td></tr>
<tr><td class="num" id="LN1542">1542</td><td class="line">		set = isl_set_from_basic_set(isl_basic_set_copy(bset));</td></tr>
<tr><td class="num" id="LN1543">1543</td><td class="line">		bset = isl_basic_set_gist(bset,</td></tr>
<tr><td class="num" id="LN1544">1544</td><td class="line">				isl_set_simple_hull(isl_set_copy(domain)));</td></tr>
<tr><td class="num" id="LN1545">1545</td><td class="line">		expr = isl_ast_build_expr_from_basic_set(build, bset);</td></tr>
<tr><td class="num" id="LN1546">1546</td><td class="line">		res = isl_ast_expr_or(res, expr);</td></tr>
<tr><td class="num" id="LN1547">1547</td><td class="line">	}</td></tr>
<tr><td class="num" id="LN1548">1548</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1549">1549</td><td class="line">	isl_set_free(domain);</td></tr>
<tr><td class="num" id="LN1550">1550</td><td class="line">	isl_set_free(set);</td></tr>
<tr><td class="num" id="LN1551">1551</td><td class="line">	isl_basic_set_list_free(list);</td></tr>
<tr><td class="num" id="LN1552">1552</td><td class="line">	<span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN1553">1553</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1554">1554</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1555">1555</td><td class="line"><span class='comment'>/* Construct an isl_ast_expr that evaluates the conditions defining "set".</span></td></tr>
<tr><td class="num" id="LN1556">1556</td><td class="line"> <span class='comment'>* The result is simplified in terms of build-&gt;domain.</span></td></tr>
<tr><td class="num" id="LN1557">1557</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN1558">1558</td><td class="line"> <span class='comment'>* If "set" is an (obviously) empty set, then return the expression "0".</span></td></tr>
<tr><td class="num" id="LN1559">1559</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN1560">1560</td><td class="line"> <span class='comment'>* "set" lives in the external schedule space.</span></td></tr>
<tr><td class="num" id="LN1561">1561</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN1562">1562</td><td class="line"> <span class='comment'>* The internal AST expression generation assumes that there are</span></td></tr>
<tr><td class="num" id="LN1563">1563</td><td class="line"> <span class='comment'>* no unknown divs, so make sure an explicit representation is available.</span></td></tr>
<tr><td class="num" id="LN1564">1564</td><td class="line"> <span class='comment'>* Since the set comes from the outside, it may have constraints that</span></td></tr>
<tr><td class="num" id="LN1565">1565</td><td class="line"> <span class='comment'>* are redundant with respect to the build domain.  Remove them first.</span></td></tr>
<tr><td class="num" id="LN1566">1566</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN1567">1567</td><td class="line"><span class='macro'>__isl_give<span class='expansion'>__attribute__((cf_returns_retained))</span></span> isl_ast_expr *isl_ast_build_expr_from_set(</td></tr>
<tr><td class="num" id="LN1568">1568</td><td class="line">	__isl_keep isl_ast_build *build, <span class='macro'>__isl_take<span class='expansion'>__attribute__((cf_consumed))</span></span> isl_set *set)</td></tr>
<tr><td class="num" id="LN1569">1569</td><td class="line">{</td></tr>
<tr><td class="num" id="LN1570">1570</td><td class="line">	<span class='keyword'>if</span> (isl_ast_build_need_schedule_map(build)) {</td></tr>
<tr><td class="num" id="LN1571">1571</td><td class="line">		isl_multi_aff *ma;</td></tr>
<tr><td class="num" id="LN1572">1572</td><td class="line">		ma = isl_ast_build_get_schedule_map_multi_aff(build);</td></tr>
<tr><td class="num" id="LN1573">1573</td><td class="line">		set = isl_set_preimage_multi_aff(set, ma);</td></tr>
<tr><td class="num" id="LN1574">1574</td><td class="line">	}</td></tr>
<tr><td class="num" id="LN1575">1575</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1576">1576</td><td class="line">	set = isl_set_compute_divs(set);</td></tr>
<tr><td class="num" id="LN1577">1577</td><td class="line">	set = isl_ast_build_compute_gist(build, set);</td></tr>
<tr><td class="num" id="LN1578">1578</td><td class="line">	<span class='keyword'>return</span> isl_ast_build_expr_from_set_internal(build, set);</td></tr>
<tr><td class="num" id="LN1579">1579</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1580">1580</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1581">1581</td><td class="line"><span class='comment'>/* State of data about previous pieces in</span></td></tr>
<tr><td class="num" id="LN1582">1582</td><td class="line"> <span class='comment'>* isl_ast_build_expr_from_pw_aff_internal.</span></td></tr>
<tr><td class="num" id="LN1583">1583</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN1584">1584</td><td class="line"> <span class='comment'>* isl_state_none: no data about previous pieces</span></td></tr>
<tr><td class="num" id="LN1585">1585</td><td class="line"> <span class='comment'>* isl_state_single: data about a single previous piece</span></td></tr>
<tr><td class="num" id="LN1586">1586</td><td class="line"> <span class='comment'>* isl_state_min: data represents minimum of several pieces</span></td></tr>
<tr><td class="num" id="LN1587">1587</td><td class="line"> <span class='comment'>* isl_state_max: data represents maximum of several pieces</span></td></tr>
<tr><td class="num" id="LN1588">1588</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN1589">1589</td><td class="line"><span class='keyword'>enum</span> isl_from_pw_aff_state {</td></tr>
<tr><td class="num" id="LN1590">1590</td><td class="line">	isl_state_none,</td></tr>
<tr><td class="num" id="LN1591">1591</td><td class="line">	isl_state_single,</td></tr>
<tr><td class="num" id="LN1592">1592</td><td class="line">	isl_state_min,</td></tr>
<tr><td class="num" id="LN1593">1593</td><td class="line">	isl_state_max</td></tr>
<tr><td class="num" id="LN1594">1594</td><td class="line">};</td></tr>
<tr><td class="num" id="LN1595">1595</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1596">1596</td><td class="line"><span class='comment'>/* Internal date structure representing a single piece in the input of</span></td></tr>
<tr><td class="num" id="LN1597">1597</td><td class="line"> <span class='comment'>* isl_ast_build_expr_from_pw_aff_internal.</span></td></tr>
<tr><td class="num" id="LN1598">1598</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN1599">1599</td><td class="line"> <span class='comment'>* If "state" is isl_state_none, then "set_list" and "aff_list" are not used.</span></td></tr>
<tr><td class="num" id="LN1600">1600</td><td class="line"> <span class='comment'>* If "state" is isl_state_single, then "set_list" and "aff_list" contain the</span></td></tr>
<tr><td class="num" id="LN1601">1601</td><td class="line"> <span class='comment'>* single previous subpiece.</span></td></tr>
<tr><td class="num" id="LN1602">1602</td><td class="line"> <span class='comment'>* If "state" is isl_state_min, then "set_list" and "aff_list" contain</span></td></tr>
<tr><td class="num" id="LN1603">1603</td><td class="line"> <span class='comment'>* a sequence of several previous subpieces that are equal to the minimum</span></td></tr>
<tr><td class="num" id="LN1604">1604</td><td class="line"> <span class='comment'>* of the entries in "aff_list" over the union of "set_list"</span></td></tr>
<tr><td class="num" id="LN1605">1605</td><td class="line"> <span class='comment'>* If "state" is isl_state_max, then "set_list" and "aff_list" contain</span></td></tr>
<tr><td class="num" id="LN1606">1606</td><td class="line"> <span class='comment'>* a sequence of several previous subpieces that are equal to the maximum</span></td></tr>
<tr><td class="num" id="LN1607">1607</td><td class="line"> <span class='comment'>* of the entries in "aff_list" over the union of "set_list"</span></td></tr>
<tr><td class="num" id="LN1608">1608</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN1609">1609</td><td class="line"> <span class='comment'>* During the construction of the pieces, "set" is NULL.</span></td></tr>
<tr><td class="num" id="LN1610">1610</td><td class="line"> <span class='comment'>* After the construction, "set" is set to the union of the elements</span></td></tr>
<tr><td class="num" id="LN1611">1611</td><td class="line"> <span class='comment'>* in "set_list", at which point "set_list" is set to NULL.</span></td></tr>
<tr><td class="num" id="LN1612">1612</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN1613">1613</td><td class="line"><span class='keyword'>struct</span> isl_from_pw_aff_piece {</td></tr>
<tr><td class="num" id="LN1614">1614</td><td class="line">	<span class='keyword'>enum</span> isl_from_pw_aff_state state;</td></tr>
<tr><td class="num" id="LN1615">1615</td><td class="line">	isl_set *set;</td></tr>
<tr><td class="num" id="LN1616">1616</td><td class="line">	isl_set_list *set_list;</td></tr>
<tr><td class="num" id="LN1617">1617</td><td class="line">	isl_aff_list *aff_list;</td></tr>
<tr><td class="num" id="LN1618">1618</td><td class="line">};</td></tr>
<tr><td class="num" id="LN1619">1619</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1620">1620</td><td class="line"><span class='comment'>/* Internal data structure for isl_ast_build_expr_from_pw_aff_internal.</span></td></tr>
<tr><td class="num" id="LN1621">1621</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN1622">1622</td><td class="line"> <span class='comment'>* "build" specifies the domain against which the result is simplified.</span></td></tr>
<tr><td class="num" id="LN1623">1623</td><td class="line"> <span class='comment'>* "dom" is the domain of the entire isl_pw_aff.</span></td></tr>
<tr><td class="num" id="LN1624">1624</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN1625">1625</td><td class="line"> <span class='comment'>* "n" is the number of pieces constructed already.</span></td></tr>
<tr><td class="num" id="LN1626">1626</td><td class="line"> <span class='comment'>* In particular, during the construction of the pieces, "n" points to</span></td></tr>
<tr><td class="num" id="LN1627">1627</td><td class="line"> <span class='comment'>* the piece that is being constructed.  After the construction of the</span></td></tr>
<tr><td class="num" id="LN1628">1628</td><td class="line"> <span class='comment'>* pieces, "n" is set to the total number of pieces.</span></td></tr>
<tr><td class="num" id="LN1629">1629</td><td class="line"> <span class='comment'>* "max" is the total number of allocated entries.</span></td></tr>
<tr><td class="num" id="LN1630">1630</td><td class="line"> <span class='comment'>* "p" contains the individual pieces.</span></td></tr>
<tr><td class="num" id="LN1631">1631</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN1632">1632</td><td class="line"><span class='keyword'>struct</span> isl_from_pw_aff_data {</td></tr>
<tr><td class="num" id="LN1633">1633</td><td class="line">	isl_ast_build *build;</td></tr>
<tr><td class="num" id="LN1634">1634</td><td class="line">	isl_set *dom;</td></tr>
<tr><td class="num" id="LN1635">1635</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1636">1636</td><td class="line">	<span class='keyword'>int</span> n;</td></tr>
<tr><td class="num" id="LN1637">1637</td><td class="line">	<span class='keyword'>int</span> max;</td></tr>
<tr><td class="num" id="LN1638">1638</td><td class="line">	<span class='keyword'>struct</span> isl_from_pw_aff_piece *p;</td></tr>
<tr><td class="num" id="LN1639">1639</td><td class="line">};</td></tr>
<tr><td class="num" id="LN1640">1640</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1641">1641</td><td class="line"><span class='comment'>/* Initialize "data" based on "build" and "pa".</span></td></tr>
<tr><td class="num" id="LN1642">1642</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN1643">1643</td><td class="line"><span class='keyword'>static</span> isl_stat isl_from_pw_aff_data_init(<span class='keyword'>struct</span> isl_from_pw_aff_data *data,</td></tr>
<tr><td class="num" id="LN1644">1644</td><td class="line">	__isl_keep isl_ast_build *build, __isl_keep isl_pw_aff *pa)</td></tr>
<tr><td class="num" id="LN1645">1645</td><td class="line">{</td></tr>
<tr><td class="num" id="LN1646">1646</td><td class="line">	<span class='keyword'>int</span> n;</td></tr>
<tr><td class="num" id="LN1647">1647</td><td class="line">	isl_ctx *ctx;</td></tr>
<tr><td class="num" id="LN1648">1648</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1649">1649</td><td class="line">	ctx = isl_pw_aff_get_ctx(pa);</td></tr>
<tr><td class="num" id="LN1650">1650</td><td class="line">	n = isl_pw_aff_n_piece(pa);</td></tr>
<tr><td class="num" id="LN1651">1651</td><td class="line">	<span class='keyword'>if</span> (n == 0)</td></tr>
<tr><td class="num" id="LN1652">1652</td><td class="line">		<span class='macro'>isl_die(ctx, isl_error_invalid,<span class='expansion'>do { isl_handle_error(ctx, isl_error_invalid, "cannot handle void expression"<br>, "/cluster/home/tgrosser/polly/llvm_git/tools/polly/lib/External/isl/isl_ast_build_expr.c"<br>, 1653); return isl_stat_error; } while (0)</span></span></td></tr>
<tr><td class="num" id="LN1653">1653</td><td class="line">			<span class='string_literal'><span class='macro'>"cannot handle void expression"</span>, <span class='keyword'>return</span> isl_stat_error)<span class='expansion'>do { isl_handle_error(ctx, isl_error_invalid, "cannot handle void expression"<br>, "/cluster/home/tgrosser/polly/llvm_git/tools/polly/lib/External/isl/isl_ast_build_expr.c"<br>, 1653); return isl_stat_error; } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1654">1654</td><td class="line">	data-&gt;max = n;</td></tr>
<tr><td class="num" id="LN1655">1655</td><td class="line">	data-&gt;p = <span class='macro'>isl_calloc_array(ctx, <span class='keyword'>struct</span> isl_from_pw_aff_piece, n)<span class='expansion'>((struct isl_from_pw_aff_piece *)isl_calloc_or_die(ctx, n, sizeof<br>(struct isl_from_pw_aff_piece)))</span></span>;</td></tr>
<tr><td class="num" id="LN1656">1656</td><td class="line">	<span class='keyword'>if</span> (!data-&gt;p)</td></tr>
<tr><td class="num" id="LN1657">1657</td><td class="line">		<span class='keyword'>return</span> isl_stat_error;</td></tr>
<tr><td class="num" id="LN1658">1658</td><td class="line">	data-&gt;build = build;</td></tr>
<tr><td class="num" id="LN1659">1659</td><td class="line">	data-&gt;dom = isl_pw_aff_domain(isl_pw_aff_copy(pa));</td></tr>
<tr><td class="num" id="LN1660">1660</td><td class="line">	data-&gt;n = 0;</td></tr>
<tr><td class="num" id="LN1661">1661</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1662">1662</td><td class="line">	<span class='keyword'>return</span> isl_stat_ok;</td></tr>
<tr><td class="num" id="LN1663">1663</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1664">1664</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1665">1665</td><td class="line"><span class='comment'>/* Free all memory allocated for "data".</span></td></tr>
<tr><td class="num" id="LN1666">1666</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN1667">1667</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>void</span> isl_from_pw_aff_data_clear(<span class='keyword'>struct</span> isl_from_pw_aff_data *data)</td></tr>
<tr><td class="num" id="LN1668">1668</td><td class="line">{</td></tr>
<tr><td class="num" id="LN1669">1669</td><td class="line">	<span class='keyword'>int</span> i;</td></tr>
<tr><td class="num" id="LN1670">1670</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1671">1671</td><td class="line">	isl_set_free(data-&gt;dom);</td></tr>
<tr><td class="num" id="LN1672">1672</td><td class="line">	<span class='keyword'>if</span> (!data-&gt;p)</td></tr>
<tr><td class="num" id="LN1673">1673</td><td class="line">		<span class='keyword'>return</span>;</td></tr>
<tr><td class="num" id="LN1674">1674</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1675">1675</td><td class="line">	<span class='keyword'>for</span> (i = 0; i &lt; data-&gt;max; ++i) {</td></tr>
<tr><td class="num" id="LN1676">1676</td><td class="line">		isl_set_free(data-&gt;p[i].set);</td></tr>
<tr><td class="num" id="LN1677">1677</td><td class="line">		isl_set_list_free(data-&gt;p[i].set_list);</td></tr>
<tr><td class="num" id="LN1678">1678</td><td class="line">		isl_aff_list_free(data-&gt;p[i].aff_list);</td></tr>
<tr><td class="num" id="LN1679">1679</td><td class="line">	}</td></tr>
<tr><td class="num" id="LN1680">1680</td><td class="line">	free(data-&gt;p);</td></tr>
<tr><td class="num" id="LN1681">1681</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1682">1682</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1683">1683</td><td class="line"><span class='comment'>/* Initialize the current entry of "data" to an unused piece.</span></td></tr>
<tr><td class="num" id="LN1684">1684</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN1685">1685</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>void</span> set_none(<span class='keyword'>struct</span> isl_from_pw_aff_data *data)</td></tr>
<tr><td class="num" id="LN1686">1686</td><td class="line">{</td></tr>
<tr><td class="num" id="LN1687">1687</td><td class="line">	data-&gt;p[data-&gt;n].state = isl_state_none;</td></tr>
<tr><td class="num" id="LN1688">1688</td><td class="line">	data-&gt;p[data-&gt;n].set_list = <span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;</td></tr>
<tr><td class="num" id="LN1689">1689</td><td class="line">	data-&gt;p[data-&gt;n].aff_list = <span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;</td></tr>
<tr><td class="num" id="LN1690">1690</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1691">1691</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1692">1692</td><td class="line"><span class='comment'>/* Store "set" and "aff" in the current entry of "data" as a single subpiece.</span></td></tr>
<tr><td class="num" id="LN1693">1693</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN1694">1694</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>void</span> set_single(<span class='keyword'>struct</span> isl_from_pw_aff_data *data,</td></tr>
<tr><td class="num" id="LN1695">1695</td><td class="line">	<span class='macro'>__isl_take<span class='expansion'>__attribute__((cf_consumed))</span></span> isl_set *set, <span class='macro'>__isl_take<span class='expansion'>__attribute__((cf_consumed))</span></span> isl_aff *aff)</td></tr>
<tr><td class="num" id="LN1696">1696</td><td class="line">{</td></tr>
<tr><td class="num" id="LN1697">1697</td><td class="line">	data-&gt;p[data-&gt;n].state = isl_state_single;</td></tr>
<tr><td class="num" id="LN1698">1698</td><td class="line">	data-&gt;p[data-&gt;n].set_list = isl_set_list_from_set(set);</td></tr>
<tr><td class="num" id="LN1699">1699</td><td class="line">	data-&gt;p[data-&gt;n].aff_list = isl_aff_list_from_aff(aff);</td></tr>
<tr><td class="num" id="LN1700">1700</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1701">1701</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1702">1702</td><td class="line"><span class='comment'>/* Extend the current entry of "data" with "set" and "aff"</span></td></tr>
<tr><td class="num" id="LN1703">1703</td><td class="line"> <span class='comment'>* as a minimum expression.</span></td></tr>
<tr><td class="num" id="LN1704">1704</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN1705">1705</td><td class="line"><span class='keyword'>static</span> isl_stat extend_min(<span class='keyword'>struct</span> isl_from_pw_aff_data *data,</td></tr>
<tr><td class="num" id="LN1706">1706</td><td class="line">	<span class='macro'>__isl_take<span class='expansion'>__attribute__((cf_consumed))</span></span> isl_set *set, <span class='macro'>__isl_take<span class='expansion'>__attribute__((cf_consumed))</span></span> isl_aff *aff)</td></tr>
<tr><td class="num" id="LN1707">1707</td><td class="line">{</td></tr>
<tr><td class="num" id="LN1708">1708</td><td class="line">	<span class='keyword'>int</span> n = data-&gt;n;</td></tr>
<tr><td class="num" id="LN1709">1709</td><td class="line">	data-&gt;p[n].state = isl_state_min;</td></tr>
<tr><td class="num" id="LN1710">1710</td><td class="line">	data-&gt;p[n].set_list = isl_set_list_add(data-&gt;p[n].set_list, set);</td></tr>
<tr><td class="num" id="LN1711">1711</td><td class="line">	data-&gt;p[n].aff_list = isl_aff_list_add(data-&gt;p[n].aff_list, aff);</td></tr>
<tr><td class="num" id="LN1712">1712</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1713">1713</td><td class="line">	<span class='keyword'>if</span> (!data-&gt;p[n].set_list || !data-&gt;p[n].aff_list)</td></tr>
<tr><td class="num" id="LN1714">1714</td><td class="line">		<span class='keyword'>return</span> isl_stat_error;</td></tr>
<tr><td class="num" id="LN1715">1715</td><td class="line">	<span class='keyword'>return</span> isl_stat_ok;</td></tr>
<tr><td class="num" id="LN1716">1716</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1717">1717</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1718">1718</td><td class="line"><span class='comment'>/* Extend the current entry of "data" with "set" and "aff"</span></td></tr>
<tr><td class="num" id="LN1719">1719</td><td class="line"> <span class='comment'>* as a maximum expression.</span></td></tr>
<tr><td class="num" id="LN1720">1720</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN1721">1721</td><td class="line"><span class='keyword'>static</span> isl_stat extend_max(<span class='keyword'>struct</span> isl_from_pw_aff_data *data,</td></tr>
<tr><td class="num" id="LN1722">1722</td><td class="line">	<span class='macro'>__isl_take<span class='expansion'>__attribute__((cf_consumed))</span></span> isl_set *set, <span class='macro'>__isl_take<span class='expansion'>__attribute__((cf_consumed))</span></span> isl_aff *aff)</td></tr>
<tr><td class="num" id="LN1723">1723</td><td class="line">{</td></tr>
<tr><td class="num" id="LN1724">1724</td><td class="line">	<span class='keyword'>int</span> n = data-&gt;n;</td></tr>
<tr><td class="num" id="LN1725">1725</td><td class="line">	data-&gt;p[n].state = isl_state_max;</td></tr>
<tr><td class="num" id="LN1726">1726</td><td class="line">	data-&gt;p[n].set_list = isl_set_list_add(data-&gt;p[n].set_list, set);</td></tr>
<tr><td class="num" id="LN1727">1727</td><td class="line">	data-&gt;p[n].aff_list = isl_aff_list_add(data-&gt;p[n].aff_list, aff);</td></tr>
<tr><td class="num" id="LN1728">1728</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1729">1729</td><td class="line">	<span class='keyword'>if</span> (!data-&gt;p[n].set_list || !data-&gt;p[n].aff_list)</td></tr>
<tr><td class="num" id="LN1730">1730</td><td class="line">		<span class='keyword'>return</span> isl_stat_error;</td></tr>
<tr><td class="num" id="LN1731">1731</td><td class="line">	<span class='keyword'>return</span> isl_stat_ok;</td></tr>
<tr><td class="num" id="LN1732">1732</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1733">1733</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1734">1734</td><td class="line"><span class='comment'>/* Extend the domain of the current entry of "data", which is assumed</span></td></tr>
<tr><td class="num" id="LN1735">1735</td><td class="line"> <span class='comment'>* to contain a single subpiece, with "set".  If "replace" is set,</span></td></tr>
<tr><td class="num" id="LN1736">1736</td><td class="line"> <span class='comment'>* then also replace the affine function by "aff".  Otherwise,</span></td></tr>
<tr><td class="num" id="LN1737">1737</td><td class="line"> <span class='comment'>* simply free "aff".</span></td></tr>
<tr><td class="num" id="LN1738">1738</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN1739">1739</td><td class="line"><span class='keyword'>static</span> isl_stat extend_domain(<span class='keyword'>struct</span> isl_from_pw_aff_data *data,</td></tr>
<tr><td class="num" id="LN1740">1740</td><td class="line">	<span class='macro'>__isl_take<span class='expansion'>__attribute__((cf_consumed))</span></span> isl_set *set, <span class='macro'>__isl_take<span class='expansion'>__attribute__((cf_consumed))</span></span> isl_aff *aff, <span class='keyword'>int</span> replace)</td></tr>
<tr><td class="num" id="LN1741">1741</td><td class="line">{</td></tr>
<tr><td class="num" id="LN1742">1742</td><td class="line">	<span class='keyword'>int</span> n = data-&gt;n;</td></tr>
<tr><td class="num" id="LN1743">1743</td><td class="line">	isl_set *set_n;</td></tr>
<tr><td class="num" id="LN1744">1744</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1745">1745</td><td class="line">	set_n = isl_set_list_get_set(data-&gt;p[n].set_list, 0);</td></tr>
<tr><td class="num" id="LN1746">1746</td><td class="line">	set_n = isl_set_union(set_n, set);</td></tr>
<tr><td class="num" id="LN1747">1747</td><td class="line">	data-&gt;p[n].set_list =</td></tr>
<tr><td class="num" id="LN1748">1748</td><td class="line">		isl_set_list_set_set(data-&gt;p[n].set_list, 0, set_n);</td></tr>
<tr><td class="num" id="LN1749">1749</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1750">1750</td><td class="line">	<span class='keyword'>if</span> (replace)</td></tr>
<tr><td class="num" id="LN1751">1751</td><td class="line">		data-&gt;p[n].aff_list =</td></tr>
<tr><td class="num" id="LN1752">1752</td><td class="line">			isl_aff_list_set_aff(data-&gt;p[n].aff_list, 0, aff);</td></tr>
<tr><td class="num" id="LN1753">1753</td><td class="line">	<span class='keyword'>else</span></td></tr>
<tr><td class="num" id="LN1754">1754</td><td class="line">		isl_aff_free(aff);</td></tr>
<tr><td class="num" id="LN1755">1755</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1756">1756</td><td class="line">	<span class='keyword'>if</span> (!data-&gt;p[n].set_list || !data-&gt;p[n].aff_list)</td></tr>
<tr><td class="num" id="LN1757">1757</td><td class="line">		<span class='keyword'>return</span> isl_stat_error;</td></tr>
<tr><td class="num" id="LN1758">1758</td><td class="line">	<span class='keyword'>return</span> isl_stat_ok;</td></tr>
<tr><td class="num" id="LN1759">1759</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1760">1760</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1761">1761</td><td class="line"><span class='comment'>/* Construct an isl_ast_expr from "list" within "build".</span></td></tr>
<tr><td class="num" id="LN1762">1762</td><td class="line"> <span class='comment'>* If "state" is isl_state_single, then "list" contains a single entry and</span></td></tr>
<tr><td class="num" id="LN1763">1763</td><td class="line"> <span class='comment'>* an isl_ast_expr is constructed for that entry.</span></td></tr>
<tr><td class="num" id="LN1764">1764</td><td class="line"> <span class='comment'>* Otherwise a min or max expression is constructed from "list"</span></td></tr>
<tr><td class="num" id="LN1765">1765</td><td class="line"> <span class='comment'>* depending on "state".</span></td></tr>
<tr><td class="num" id="LN1766">1766</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN1767">1767</td><td class="line"><span class='keyword'>static</span> <span class='macro'>__isl_give<span class='expansion'>__attribute__((cf_returns_retained))</span></span> isl_ast_expr *ast_expr_from_aff_list(</td></tr>
<tr><td class="num" id="LN1768">1768</td><td class="line">	<span class='macro'>__isl_take<span class='expansion'>__attribute__((cf_consumed))</span></span> isl_aff_list *list, <span class='keyword'>enum</span> isl_from_pw_aff_state state,</td></tr>
<tr><td class="num" id="LN1769">1769</td><td class="line">	__isl_keep isl_ast_build *build)</td></tr>
<tr><td class="num" id="LN1770">1770</td><td class="line">{</td></tr>
<tr><td class="num" id="LN1771">1771</td><td class="line">	<span class='keyword'>int</span> i, n;</td></tr>
<tr><td class="num" id="LN1772">1772</td><td class="line">	isl_aff *aff;</td></tr>
<tr><td class="num" id="LN1773">1773</td><td class="line">	isl_ast_expr *expr;</td></tr>
<tr><td class="num" id="LN1774">1774</td><td class="line">	<span class='keyword'>enum</span> isl_ast_op_type op_type;</td></tr>
<tr><td class="num" id="LN1775">1775</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1776">1776</td><td class="line">	<span class='keyword'>if</span> (state == isl_state_single) {</td></tr>
<tr><td class="num" id="LN1777">1777</td><td class="line">		aff = isl_aff_list_get_aff(list, 0);</td></tr>
<tr><td class="num" id="LN1778">1778</td><td class="line">		isl_aff_list_free(list);</td></tr>
<tr><td class="num" id="LN1779">1779</td><td class="line">		<span class='keyword'>return</span> isl_ast_expr_from_aff(aff, build);</td></tr>
<tr><td class="num" id="LN1780">1780</td><td class="line">	}</td></tr>
<tr><td class="num" id="LN1781">1781</td><td class="line">	n = isl_aff_list_n_aff(list);</td></tr>
<tr><td class="num" id="LN1782">1782</td><td class="line">	op_type = state == isl_state_min ? isl_ast_op_min : isl_ast_op_max;</td></tr>
<tr><td class="num" id="LN1783">1783</td><td class="line">	expr = isl_ast_expr_alloc_op(isl_ast_build_get_ctx(build), op_type, n);</td></tr>
<tr><td class="num" id="LN1784">1784</td><td class="line">	<span class='keyword'>if</span> (!expr)</td></tr>
<tr><td class="num" id="LN1785">1785</td><td class="line">		<span class='keyword'>goto</span> error;</td></tr>
<tr><td class="num" id="LN1786">1786</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1787">1787</td><td class="line">	<span class='keyword'>for</span> (i = 0; i &lt; n; ++i) {</td></tr>
<tr><td class="num" id="LN1788">1788</td><td class="line">		isl_ast_expr *expr_i;</td></tr>
<tr><td class="num" id="LN1789">1789</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1790">1790</td><td class="line">		aff = isl_aff_list_get_aff(list, i);</td></tr>
<tr><td class="num" id="LN1791">1791</td><td class="line">		expr_i = isl_ast_expr_from_aff(aff, build);</td></tr>
<tr><td class="num" id="LN1792">1792</td><td class="line">		<span class='keyword'>if</span> (!expr_i)</td></tr>
<tr><td class="num" id="LN1793">1793</td><td class="line">			<span class='keyword'>goto</span> error;</td></tr>
<tr><td class="num" id="LN1794">1794</td><td class="line">		expr-&gt;u.op.args[i] = expr_i;</td></tr>
<tr><td class="num" id="LN1795">1795</td><td class="line">	}</td></tr>
<tr><td class="num" id="LN1796">1796</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1797">1797</td><td class="line">	isl_aff_list_free(list);</td></tr>
<tr><td class="num" id="LN1798">1798</td><td class="line">	<span class='keyword'>return</span> expr;</td></tr>
<tr><td class="num" id="LN1799">1799</td><td class="line">error:</td></tr>
<tr><td class="num" id="LN1800">1800</td><td class="line">	isl_aff_list_free(list);</td></tr>
<tr><td class="num" id="LN1801">1801</td><td class="line">	isl_ast_expr_free(expr);</td></tr>
<tr><td class="num" id="LN1802">1802</td><td class="line">	<span class='keyword'>return</span> <span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;</td></tr>
<tr><td class="num" id="LN1803">1803</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1804">1804</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1805">1805</td><td class="line"><span class='comment'>/* Extend the expression in "next" to take into account</span></td></tr>
<tr><td class="num" id="LN1806">1806</td><td class="line"> <span class='comment'>* the piece at position "pos" in "data", allowing for a further extension</span></td></tr>
<tr><td class="num" id="LN1807">1807</td><td class="line"> <span class='comment'>* for the next piece(s).</span></td></tr>
<tr><td class="num" id="LN1808">1808</td><td class="line"> <span class='comment'>* In particular, "next" is set to a select operation that selects</span></td></tr>
<tr><td class="num" id="LN1809">1809</td><td class="line"> <span class='comment'>* an isl_ast_expr corresponding to data-&gt;aff_list on data-&gt;set and</span></td></tr>
<tr><td class="num" id="LN1810">1810</td><td class="line"> <span class='comment'>* to an expression that will be filled in by later calls.</span></td></tr>
<tr><td class="num" id="LN1811">1811</td><td class="line"> <span class='comment'>* Return a pointer to this location.</span></td></tr>
<tr><td class="num" id="LN1812">1812</td><td class="line"> <span class='comment'>* Afterwards, the state of "data" is set to isl_state_none.</span></td></tr>
<tr><td class="num" id="LN1813">1813</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN1814">1814</td><td class="line"> <span class='comment'>* The constraints of data-&gt;set are added to the generated</span></td></tr>
<tr><td class="num" id="LN1815">1815</td><td class="line"> <span class='comment'>* constraints of the build such that they can be exploited to simplify</span></td></tr>
<tr><td class="num" id="LN1816">1816</td><td class="line"> <span class='comment'>* the AST expression constructed from data-&gt;aff_list.</span></td></tr>
<tr><td class="num" id="LN1817">1817</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN1818">1818</td><td class="line"><span class='keyword'>static</span> isl_ast_expr **add_intermediate_piece(<span class='keyword'>struct</span> isl_from_pw_aff_data *data,</td></tr>
<tr><td class="num" id="LN1819">1819</td><td class="line">	<span class='keyword'>int</span> pos, isl_ast_expr **next)</td></tr>
<tr><td class="num" id="LN1820">1820</td><td class="line">{</td></tr>
<tr><td class="num" id="LN1821">1821</td><td class="line">	isl_ctx *ctx;</td></tr>
<tr><td class="num" id="LN1822">1822</td><td class="line">	isl_ast_build *build;</td></tr>
<tr><td class="num" id="LN1823">1823</td><td class="line">	isl_ast_expr *ternary, *arg;</td></tr>
<tr><td class="num" id="LN1824">1824</td><td class="line">	isl_set *set, *gist;</td></tr>
<tr><td class="num" id="LN1825">1825</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1826">1826</td><td class="line">	set = data-&gt;p[pos].set;</td></tr>
<tr><td class="num" id="LN1827">1827</td><td class="line">	data-&gt;p[pos].set = <span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;</td></tr>
<tr><td class="num" id="LN1828">1828</td><td class="line">	ctx = isl_ast_build_get_ctx(data-&gt;build);</td></tr>
<tr><td class="num" id="LN1829">1829</td><td class="line">	ternary = isl_ast_expr_alloc_op(ctx, isl_ast_op_select, 3);</td></tr>
<tr><td class="num" id="LN1830">1830</td><td class="line">	gist = isl_set_gist(isl_set_copy(set), isl_set_copy(data-&gt;dom));</td></tr>
<tr><td class="num" id="LN1831">1831</td><td class="line">	arg = isl_ast_build_expr_from_set_internal(data-&gt;build, gist);</td></tr>
<tr><td class="num" id="LN1832">1832</td><td class="line">	ternary = isl_ast_expr_set_op_arg(ternary, 0, arg);</td></tr>
<tr><td class="num" id="LN1833">1833</td><td class="line">	build = isl_ast_build_copy(data-&gt;build);</td></tr>
<tr><td class="num" id="LN1834">1834</td><td class="line">	build = isl_ast_build_restrict_generated(build, set);</td></tr>
<tr><td class="num" id="LN1835">1835</td><td class="line">	arg = ast_expr_from_aff_list(data-&gt;p[pos].aff_list,</td></tr>
<tr><td class="num" id="LN1836">1836</td><td class="line">					data-&gt;p[pos].state, build);</td></tr>
<tr><td class="num" id="LN1837">1837</td><td class="line">	data-&gt;p[pos].aff_list = <span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;</td></tr>
<tr><td class="num" id="LN1838">1838</td><td class="line">	isl_ast_build_free(build);</td></tr>
<tr><td class="num" id="LN1839">1839</td><td class="line">	ternary = isl_ast_expr_set_op_arg(ternary, 1, arg);</td></tr>
<tr><td class="num" id="LN1840">1840</td><td class="line">	data-&gt;p[pos].state = isl_state_none;</td></tr>
<tr><td class="num" id="LN1841">1841</td><td class="line">	<span class='keyword'>if</span> (!ternary)</td></tr>
<tr><td class="num" id="LN1842">1842</td><td class="line">		<span class='keyword'>return</span> <span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;</td></tr>
<tr><td class="num" id="LN1843">1843</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1844">1844</td><td class="line">	*next = ternary;</td></tr>
<tr><td class="num" id="LN1845">1845</td><td class="line">	<span class='keyword'>return</span> &amp;ternary-&gt;u.op.args[2];</td></tr>
<tr><td class="num" id="LN1846">1846</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1847">1847</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1848">1848</td><td class="line"><span class='comment'>/* Extend the expression in "next" to take into account</span></td></tr>
<tr><td class="num" id="LN1849">1849</td><td class="line"> <span class='comment'>* the final piece, located at position "pos" in "data".</span></td></tr>
<tr><td class="num" id="LN1850">1850</td><td class="line"> <span class='comment'>* In particular, "next" is set to evaluate data-&gt;aff_list</span></td></tr>
<tr><td class="num" id="LN1851">1851</td><td class="line"> <span class='comment'>* and the domain is ignored.</span></td></tr>
<tr><td class="num" id="LN1852">1852</td><td class="line"> <span class='comment'>* Return isl_stat_ok on success and isl_stat_error on failure.</span></td></tr>
<tr><td class="num" id="LN1853">1853</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN1854">1854</td><td class="line"> <span class='comment'>* The constraints of data-&gt;set are however added to the generated</span></td></tr>
<tr><td class="num" id="LN1855">1855</td><td class="line"> <span class='comment'>* constraints of the build such that they can be exploited to simplify</span></td></tr>
<tr><td class="num" id="LN1856">1856</td><td class="line"> <span class='comment'>* the AST expression constructed from data-&gt;aff_list.</span></td></tr>
<tr><td class="num" id="LN1857">1857</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN1858">1858</td><td class="line"><span class='keyword'>static</span> isl_stat add_last_piece(<span class='keyword'>struct</span> isl_from_pw_aff_data *data,</td></tr>
<tr><td class="num" id="LN1859">1859</td><td class="line">	<span class='keyword'>int</span> pos, isl_ast_expr **next)</td></tr>
<tr><td class="num" id="LN1860">1860</td><td class="line">{</td></tr>
<tr><td class="num" id="LN1861">1861</td><td class="line">	isl_ast_build *build;</td></tr>
<tr><td class="num" id="LN1862">1862</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1863">1863</td><td class="line">	<span class='keyword'>if</span> (data-&gt;p[pos].state == isl_state_none)</td></tr>
<tr><td class="num" id="LN1864">1864</td><td class="line">		<span class='macro'>isl_die(isl_ast_build_get_ctx(data-&gt;build), isl_error_invalid,<span class='expansion'>do { isl_handle_error(isl_ast_build_get_ctx(data-&gt;build), isl_error_invalid<br>, "cannot handle void expression", "/cluster/home/tgrosser/polly/llvm_git/tools/polly/lib/External/isl/isl_ast_build_expr.c"<br>, 1865); return isl_stat_error; } while (0)</span></span></td></tr>
<tr><td class="num" id="LN1865">1865</td><td class="line">			<span class='string_literal'><span class='macro'>"cannot handle void expression"</span>, <span class='keyword'>return</span> isl_stat_error)<span class='expansion'>do { isl_handle_error(isl_ast_build_get_ctx(data-&gt;build), isl_error_invalid<br>, "cannot handle void expression", "/cluster/home/tgrosser/polly/llvm_git/tools/polly/lib/External/isl/isl_ast_build_expr.c"<br>, 1865); return isl_stat_error; } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1866">1866</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1867">1867</td><td class="line">	build = isl_ast_build_copy(data-&gt;build);</td></tr>
<tr><td class="num" id="LN1868">1868</td><td class="line">	build = isl_ast_build_restrict_generated(build, data-&gt;p[pos].set);</td></tr>
<tr><td class="num" id="LN1869">1869</td><td class="line">	data-&gt;p[pos].set = <span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;</td></tr>
<tr><td class="num" id="LN1870">1870</td><td class="line">	*next = ast_expr_from_aff_list(data-&gt;p[pos].aff_list,</td></tr>
<tr><td class="num" id="LN1871">1871</td><td class="line">						data-&gt;p[pos].state, build);</td></tr>
<tr><td class="num" id="LN1872">1872</td><td class="line">	data-&gt;p[pos].aff_list = <span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;</td></tr>
<tr><td class="num" id="LN1873">1873</td><td class="line">	isl_ast_build_free(build);</td></tr>
<tr><td class="num" id="LN1874">1874</td><td class="line">	data-&gt;p[pos].state = isl_state_none;</td></tr>
<tr><td class="num" id="LN1875">1875</td><td class="line">	<span class='keyword'>if</span> (!*next)</td></tr>
<tr><td class="num" id="LN1876">1876</td><td class="line">		<span class='keyword'>return</span> isl_stat_error;</td></tr>
<tr><td class="num" id="LN1877">1877</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1878">1878</td><td class="line">	<span class='keyword'>return</span> isl_stat_ok;</td></tr>
<tr><td class="num" id="LN1879">1879</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1880">1880</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1881">1881</td><td class="line"><span class='comment'>/* Return -1 if the piece "p1" should be sorted before "p2"</span></td></tr>
<tr><td class="num" id="LN1882">1882</td><td class="line"> <span class='comment'>* and 1 if it should be sorted after "p2".</span></td></tr>
<tr><td class="num" id="LN1883">1883</td><td class="line"> <span class='comment'>* Return 0 if they do not need to be sorted in a specific order.</span></td></tr>
<tr><td class="num" id="LN1884">1884</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN1885">1885</td><td class="line"> <span class='comment'>* Pieces are sorted according to the number of disjuncts</span></td></tr>
<tr><td class="num" id="LN1886">1886</td><td class="line"> <span class='comment'>* in their domains.</span></td></tr>
<tr><td class="num" id="LN1887">1887</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN1888">1888</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>int</span> sort_pieces_cmp(<span class='keyword'>const</span> <span class='keyword'>void</span> *p1, <span class='keyword'>const</span> <span class='keyword'>void</span> *p2, <span class='keyword'>void</span> *arg)</td></tr>
<tr><td class="num" id="LN1889">1889</td><td class="line">{</td></tr>
<tr><td class="num" id="LN1890">1890</td><td class="line">	<span class='keyword'>const</span> <span class='keyword'>struct</span> isl_from_pw_aff_piece *piece1 = p1;</td></tr>
<tr><td class="num" id="LN1891">1891</td><td class="line">	<span class='keyword'>const</span> <span class='keyword'>struct</span> isl_from_pw_aff_piece *piece2 = p2;</td></tr>
<tr><td class="num" id="LN1892">1892</td><td class="line">	<span class='keyword'>int</span> n1, n2;</td></tr>
<tr><td class="num" id="LN1893">1893</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1894">1894</td><td class="line">	n1 = isl_set_n_basic_set(piece1-&gt;set);</td></tr>
<tr><td class="num" id="LN1895">1895</td><td class="line">	n2 = isl_set_n_basic_set(piece2-&gt;set);</td></tr>
<tr><td class="num" id="LN1896">1896</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1897">1897</td><td class="line">	<span class='keyword'>return</span> n1 - n2;</td></tr>
<tr><td class="num" id="LN1898">1898</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1899">1899</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1900">1900</td><td class="line"><span class='comment'>/* Construct an isl_ast_expr from the pieces in "data".</span></td></tr>
<tr><td class="num" id="LN1901">1901</td><td class="line"> <span class='comment'>* Return the result or NULL on failure.</span></td></tr>
<tr><td class="num" id="LN1902">1902</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN1903">1903</td><td class="line"> <span class='comment'>* When this function is called, data-&gt;n points to the current piece.</span></td></tr>
<tr><td class="num" id="LN1904">1904</td><td class="line"> <span class='comment'>* If this is an effective piece, then first increment data-&gt;n such</span></td></tr>
<tr><td class="num" id="LN1905">1905</td><td class="line"> <span class='comment'>* that data-&gt;n contains the number of pieces.</span></td></tr>
<tr><td class="num" id="LN1906">1906</td><td class="line"> <span class='comment'>* The "set_list" fields are subsequently replaced by the corresponding</span></td></tr>
<tr><td class="num" id="LN1907">1907</td><td class="line"> <span class='comment'>* "set" fields, after which the pieces are sorted according to</span></td></tr>
<tr><td class="num" id="LN1908">1908</td><td class="line"> <span class='comment'>* the number of disjuncts in these "set" fields.</span></td></tr>
<tr><td class="num" id="LN1909">1909</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN1910">1910</td><td class="line"> <span class='comment'>* Construct intermediate AST expressions for the initial pieces and</span></td></tr>
<tr><td class="num" id="LN1911">1911</td><td class="line"> <span class='comment'>* finish off with the final pieces.</span></td></tr>
<tr><td class="num" id="LN1912">1912</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN1913">1913</td><td class="line"><span class='keyword'>static</span> isl_ast_expr *build_pieces(<span class='keyword'>struct</span> isl_from_pw_aff_data *data)</td></tr>
<tr><td class="num" id="LN1914">1914</td><td class="line">{</td></tr>
<tr><td class="num" id="LN1915">1915</td><td class="line">	<span class='keyword'>int</span> i;</td></tr>
<tr><td class="num" id="LN1916">1916</td><td class="line">	isl_ast_expr *res = <span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;</td></tr>
<tr><td class="num" id="LN1917">1917</td><td class="line">	isl_ast_expr **next = &amp;res;</td></tr>
<tr><td class="num" id="LN1918">1918</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1919">1919</td><td class="line">	<span class='keyword'>if</span> (data-&gt;p[data-&gt;n].state != isl_state_none)</td></tr>
<tr><td class="num" id="LN1920">1920</td><td class="line">		data-&gt;n++;</td></tr>
<tr><td class="num" id="LN1921">1921</td><td class="line">	<span class='keyword'>if</span> (data-&gt;n == 0)</td></tr>
<tr><td class="num" id="LN1922">1922</td><td class="line">		<span class='macro'>isl_die(isl_ast_build_get_ctx(data-&gt;build), isl_error_invalid,<span class='expansion'>do { isl_handle_error(isl_ast_build_get_ctx(data-&gt;build), isl_error_invalid<br>, "cannot handle void expression", "/cluster/home/tgrosser/polly/llvm_git/tools/polly/lib/External/isl/isl_ast_build_expr.c"<br>, 1923); return ((void*)0); } while (0)</span></span></td></tr>
<tr><td class="num" id="LN1923">1923</td><td class="line">			<span class='string_literal'><span class='macro'>"cannot handle void expression"</span>, <span class='keyword'>return</span> NULL)<span class='expansion'>do { isl_handle_error(isl_ast_build_get_ctx(data-&gt;build), isl_error_invalid<br>, "cannot handle void expression", "/cluster/home/tgrosser/polly/llvm_git/tools/polly/lib/External/isl/isl_ast_build_expr.c"<br>, 1923); return ((void*)0); } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN1924">1924</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1925">1925</td><td class="line">	<span class='keyword'>for</span> (i = 0; i &lt; data-&gt;n; ++i) {</td></tr>
<tr><td class="num" id="LN1926">1926</td><td class="line">		data-&gt;p[i].set = isl_set_list_union(data-&gt;p[i].set_list);</td></tr>
<tr><td class="num" id="LN1927">1927</td><td class="line">		<span class='keyword'>if</span> (data-&gt;p[i].state != isl_state_single)</td></tr>
<tr><td class="num" id="LN1928">1928</td><td class="line">			data-&gt;p[i].set = isl_set_coalesce(data-&gt;p[i].set);</td></tr>
<tr><td class="num" id="LN1929">1929</td><td class="line">		data-&gt;p[i].set_list = <span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;</td></tr>
<tr><td class="num" id="LN1930">1930</td><td class="line">	}</td></tr>
<tr><td class="num" id="LN1931">1931</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1932">1932</td><td class="line">	<span class='keyword'>if</span> (isl_sort(data-&gt;p, data-&gt;n, <span class='keyword'>sizeof</span>(data-&gt;p[0]),</td></tr>
<tr><td class="num" id="LN1933">1933</td><td class="line">			&amp;sort_pieces_cmp, <span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) &lt; 0)</td></tr>
<tr><td class="num" id="LN1934">1934</td><td class="line">		<span class='keyword'>return</span> isl_ast_expr_free(res);</td></tr>
<tr><td class="num" id="LN1935">1935</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1936">1936</td><td class="line">	<span class='keyword'>for</span> (i = 0; i + 1 &lt; data-&gt;n; ++i) {</td></tr>
<tr><td class="num" id="LN1937">1937</td><td class="line">		next = add_intermediate_piece(data, i, next);</td></tr>
<tr><td class="num" id="LN1938">1938</td><td class="line">		<span class='keyword'>if</span> (!next)</td></tr>
<tr><td class="num" id="LN1939">1939</td><td class="line">			<span class='keyword'>return</span> isl_ast_expr_free(res);</td></tr>
<tr><td class="num" id="LN1940">1940</td><td class="line">	}</td></tr>
<tr><td class="num" id="LN1941">1941</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1942">1942</td><td class="line">	<span class='keyword'>if</span> (add_last_piece(data, data-&gt;n - 1, next) &lt; 0)</td></tr>
<tr><td class="num" id="LN1943">1943</td><td class="line">		<span class='keyword'>return</span> isl_ast_expr_free(res);</td></tr>
<tr><td class="num" id="LN1944">1944</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1945">1945</td><td class="line">	<span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN1946">1946</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1947">1947</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1948">1948</td><td class="line"><span class='comment'>/* Is the domain of the current entry of "data", which is assumed</span></td></tr>
<tr><td class="num" id="LN1949">1949</td><td class="line"> <span class='comment'>* to contain a single subpiece, a subset of "set"?</span></td></tr>
<tr><td class="num" id="LN1950">1950</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN1951">1951</td><td class="line"><span class='keyword'>static</span> isl_bool single_is_subset(<span class='keyword'>struct</span> isl_from_pw_aff_data *data,</td></tr>
<tr><td class="num" id="LN1952">1952</td><td class="line">	__isl_keep isl_set *set)</td></tr>
<tr><td class="num" id="LN1953">1953</td><td class="line">{</td></tr>
<tr><td class="num" id="LN1954">1954</td><td class="line">	isl_bool subset;</td></tr>
<tr><td class="num" id="LN1955">1955</td><td class="line">	isl_set *set_n;</td></tr>
<tr><td class="num" id="LN1956">1956</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1957">1957</td><td class="line">	set_n = isl_set_list_get_set(data-&gt;p[data-&gt;n].set_list, 0);</td></tr>
<tr><td class="num" id="LN1958">1958</td><td class="line">	subset = isl_set_is_subset(set_n, set);</td></tr>
<tr><td class="num" id="LN1959">1959</td><td class="line">	isl_set_free(set_n);</td></tr>
<tr><td class="num" id="LN1960">1960</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1961">1961</td><td class="line">	<span class='keyword'>return</span> subset;</td></tr>
<tr><td class="num" id="LN1962">1962</td><td class="line">}</td></tr>
<tr><td class="num" id="LN1963">1963</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1964">1964</td><td class="line"><span class='comment'>/* Can the list of subpieces in the last piece of "data" be extended with</span></td></tr>
<tr><td class="num" id="LN1965">1965</td><td class="line"> <span class='comment'>* "set" and "aff" based on "test"?</span></td></tr>
<tr><td class="num" id="LN1966">1966</td><td class="line"> <span class='comment'>* In particular, is it the case for each entry (set_i, aff_i) that</span></td></tr>
<tr><td class="num" id="LN1967">1967</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN1968">1968</td><td class="line"> <span class='comment'>*	test(aff, aff_i) holds on set_i, and</span></td></tr>
<tr><td class="num" id="LN1969">1969</td><td class="line"> <span class='comment'>*	test(aff_i, aff) holds on set?</span></td></tr>
<tr><td class="num" id="LN1970">1970</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN1971">1971</td><td class="line"> <span class='comment'>* "test" returns the set of elements where the tests holds, meaning</span></td></tr>
<tr><td class="num" id="LN1972">1972</td><td class="line"> <span class='comment'>* that test(aff_i, aff) holds on set if set is a subset of test(aff_i, aff).</span></td></tr>
<tr><td class="num" id="LN1973">1973</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN1974">1974</td><td class="line"> <span class='comment'>* This function is used to detect min/max expressions.</span></td></tr>
<tr><td class="num" id="LN1975">1975</td><td class="line"> <span class='comment'>* If the ast_build_detect_min_max option is turned off, then</span></td></tr>
<tr><td class="num" id="LN1976">1976</td><td class="line"> <span class='comment'>* do not even try and perform any detection and return false instead.</span></td></tr>
<tr><td class="num" id="LN1977">1977</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN1978">1978</td><td class="line"><span class='keyword'>static</span> isl_bool extends(<span class='keyword'>struct</span> isl_from_pw_aff_data *data,</td></tr>
<tr><td class="num" id="LN1979">1979</td><td class="line">	__isl_keep isl_set *set, __isl_keep isl_aff *aff,</td></tr>
<tr><td class="num" id="LN1980">1980</td><td class="line">	<span class='macro'>__isl_give<span class='expansion'>__attribute__((cf_returns_retained))</span></span> isl_basic_set *(*test)(<span class='macro'>__isl_take<span class='expansion'>__attribute__((cf_consumed))</span></span> isl_aff *aff1,</td></tr>
<tr><td class="num" id="LN1981">1981</td><td class="line">		<span class='macro'>__isl_take<span class='expansion'>__attribute__((cf_consumed))</span></span> isl_aff *aff2))</td></tr>
<tr><td class="num" id="LN1982">1982</td><td class="line">{</td></tr>
<tr><td class="num" id="LN1983">1983</td><td class="line">	<span class='keyword'>int</span> i, n;</td></tr>
<tr><td class="num" id="LN1984">1984</td><td class="line">	isl_ctx *ctx;</td></tr>
<tr><td class="num" id="LN1985">1985</td><td class="line">	isl_set *dom;</td></tr>
<tr><td class="num" id="LN1986">1986</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1987">1987</td><td class="line">	ctx = isl_ast_build_get_ctx(data-&gt;build);</td></tr>
<tr><td class="num" id="LN1988">1988</td><td class="line">	<span class='keyword'>if</span> (!isl_options_get_ast_build_detect_min_max(ctx))</td></tr>
<tr><td class="num" id="LN1989">1989</td><td class="line">		<span class='keyword'>return</span> isl_bool_false;</td></tr>
<tr><td class="num" id="LN1990">1990</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1991">1991</td><td class="line">	dom = isl_ast_build_get_domain(data-&gt;build);</td></tr>
<tr><td class="num" id="LN1992">1992</td><td class="line">	set = isl_set_intersect(dom, isl_set_copy(set));</td></tr>
<tr><td class="num" id="LN1993">1993</td><td class="line"> </td></tr>
<tr><td class="num" id="LN1994">1994</td><td class="line">	n = isl_set_list_n_set(data-&gt;p[data-&gt;n].set_list);</td></tr>
<tr><td class="num" id="LN1995">1995</td><td class="line">	<span class='keyword'>for</span> (i = 0; i &lt; n ; ++i) {</td></tr>
<tr><td class="num" id="LN1996">1996</td><td class="line">		isl_aff *aff_i;</td></tr>
<tr><td class="num" id="LN1997">1997</td><td class="line">		isl_set *valid;</td></tr>
<tr><td class="num" id="LN1998">1998</td><td class="line">		isl_set *dom, *required;</td></tr>
<tr><td class="num" id="LN1999">1999</td><td class="line">		isl_bool is_valid;</td></tr>
<tr><td class="num" id="LN2000">2000</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2001">2001</td><td class="line">		aff_i = isl_aff_list_get_aff(data-&gt;p[data-&gt;n].aff_list, i);</td></tr>
<tr><td class="num" id="LN2002">2002</td><td class="line">		valid = isl_set_from_basic_set(test(isl_aff_copy(aff), aff_i));</td></tr>
<tr><td class="num" id="LN2003">2003</td><td class="line">		required = isl_set_list_get_set(data-&gt;p[data-&gt;n].set_list, i);</td></tr>
<tr><td class="num" id="LN2004">2004</td><td class="line">		dom = isl_ast_build_get_domain(data-&gt;build);</td></tr>
<tr><td class="num" id="LN2005">2005</td><td class="line">		required = isl_set_intersect(dom, required);</td></tr>
<tr><td class="num" id="LN2006">2006</td><td class="line">		is_valid = isl_set_is_subset(required, valid);</td></tr>
<tr><td class="num" id="LN2007">2007</td><td class="line">		isl_set_free(required);</td></tr>
<tr><td class="num" id="LN2008">2008</td><td class="line">		isl_set_free(valid);</td></tr>
<tr><td class="num" id="LN2009">2009</td><td class="line">		<span class='keyword'>if</span> (is_valid &lt; 0 || !is_valid) {</td></tr>
<tr><td class="num" id="LN2010">2010</td><td class="line">			isl_set_free(set);</td></tr>
<tr><td class="num" id="LN2011">2011</td><td class="line">			<span class='keyword'>return</span> is_valid;</td></tr>
<tr><td class="num" id="LN2012">2012</td><td class="line">		}</td></tr>
<tr><td class="num" id="LN2013">2013</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2014">2014</td><td class="line">		aff_i = isl_aff_list_get_aff(data-&gt;p[data-&gt;n].aff_list, i);</td></tr>
<tr><td class="num" id="LN2015">2015</td><td class="line">		valid = isl_set_from_basic_set(test(aff_i, isl_aff_copy(aff)));</td></tr>
<tr><td class="num" id="LN2016">2016</td><td class="line">		is_valid = isl_set_is_subset(set, valid);</td></tr>
<tr><td class="num" id="LN2017">2017</td><td class="line">		isl_set_free(valid);</td></tr>
<tr><td class="num" id="LN2018">2018</td><td class="line">		<span class='keyword'>if</span> (is_valid &lt; 0 || !is_valid) {</td></tr>
<tr><td class="num" id="LN2019">2019</td><td class="line">			isl_set_free(set);</td></tr>
<tr><td class="num" id="LN2020">2020</td><td class="line">			<span class='keyword'>return</span> is_valid;</td></tr>
<tr><td class="num" id="LN2021">2021</td><td class="line">		}</td></tr>
<tr><td class="num" id="LN2022">2022</td><td class="line">	}</td></tr>
<tr><td class="num" id="LN2023">2023</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2024">2024</td><td class="line">	isl_set_free(set);</td></tr>
<tr><td class="num" id="LN2025">2025</td><td class="line">	<span class='keyword'>return</span> isl_bool_true;</td></tr>
<tr><td class="num" id="LN2026">2026</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2027">2027</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2028">2028</td><td class="line"><span class='comment'>/* Can the list of pieces in "data" be extended with "set" and "aff"</span></td></tr>
<tr><td class="num" id="LN2029">2029</td><td class="line"> <span class='comment'>* to form/preserve a minimum expression?</span></td></tr>
<tr><td class="num" id="LN2030">2030</td><td class="line"> <span class='comment'>* In particular, is it the case for each entry (set_i, aff_i) that</span></td></tr>
<tr><td class="num" id="LN2031">2031</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN2032">2032</td><td class="line"> <span class='comment'>*	aff &gt;= aff_i on set_i, and</span></td></tr>
<tr><td class="num" id="LN2033">2033</td><td class="line"> <span class='comment'>*	aff_i &gt;= aff on set?</span></td></tr>
<tr><td class="num" id="LN2034">2034</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN2035">2035</td><td class="line"><span class='keyword'>static</span> isl_bool extends_min(<span class='keyword'>struct</span> isl_from_pw_aff_data *data,</td></tr>
<tr><td class="num" id="LN2036">2036</td><td class="line">	__isl_keep isl_set *set,  __isl_keep isl_aff *aff)</td></tr>
<tr><td class="num" id="LN2037">2037</td><td class="line">{</td></tr>
<tr><td class="num" id="LN2038">2038</td><td class="line">	<span class='keyword'>return</span> extends(data, set, aff, &amp;isl_aff_ge_basic_set);</td></tr>
<tr><td class="num" id="LN2039">2039</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2040">2040</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2041">2041</td><td class="line"><span class='comment'>/* Can the list of pieces in "data" be extended with "set" and "aff"</span></td></tr>
<tr><td class="num" id="LN2042">2042</td><td class="line"> <span class='comment'>* to form/preserve a maximum expression?</span></td></tr>
<tr><td class="num" id="LN2043">2043</td><td class="line"> <span class='comment'>* In particular, is it the case for each entry (set_i, aff_i) that</span></td></tr>
<tr><td class="num" id="LN2044">2044</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN2045">2045</td><td class="line"> <span class='comment'>*	aff &lt;= aff_i on set_i, and</span></td></tr>
<tr><td class="num" id="LN2046">2046</td><td class="line"> <span class='comment'>*	aff_i &lt;= aff on set?</span></td></tr>
<tr><td class="num" id="LN2047">2047</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN2048">2048</td><td class="line"><span class='keyword'>static</span> isl_bool extends_max(<span class='keyword'>struct</span> isl_from_pw_aff_data *data,</td></tr>
<tr><td class="num" id="LN2049">2049</td><td class="line">	__isl_keep isl_set *set,  __isl_keep isl_aff *aff)</td></tr>
<tr><td class="num" id="LN2050">2050</td><td class="line">{</td></tr>
<tr><td class="num" id="LN2051">2051</td><td class="line">	<span class='keyword'>return</span> extends(data, set, aff, &amp;isl_aff_le_basic_set);</td></tr>
<tr><td class="num" id="LN2052">2052</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2053">2053</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2054">2054</td><td class="line"><span class='comment'>/* This function is called during the construction of an isl_ast_expr</span></td></tr>
<tr><td class="num" id="LN2055">2055</td><td class="line"> <span class='comment'>* that evaluates an isl_pw_aff.</span></td></tr>
<tr><td class="num" id="LN2056">2056</td><td class="line"> <span class='comment'>* If the last piece of "data" contains a single subpiece and</span></td></tr>
<tr><td class="num" id="LN2057">2057</td><td class="line"> <span class='comment'>* if its affine function is equal to "aff" on a part of the domain</span></td></tr>
<tr><td class="num" id="LN2058">2058</td><td class="line"> <span class='comment'>* that includes either "set" or the domain of that single subpiece,</span></td></tr>
<tr><td class="num" id="LN2059">2059</td><td class="line"> <span class='comment'>* then extend the domain of that single subpiece with "set".</span></td></tr>
<tr><td class="num" id="LN2060">2060</td><td class="line"> <span class='comment'>* If it was the original domain of the single subpiece where</span></td></tr>
<tr><td class="num" id="LN2061">2061</td><td class="line"> <span class='comment'>* the two affine functions are equal, then also replace</span></td></tr>
<tr><td class="num" id="LN2062">2062</td><td class="line"> <span class='comment'>* the affine function of the single subpiece by "aff".</span></td></tr>
<tr><td class="num" id="LN2063">2063</td><td class="line"> <span class='comment'>* If the last piece of "data" contains either a single subpiece</span></td></tr>
<tr><td class="num" id="LN2064">2064</td><td class="line"> <span class='comment'>* or a minimum, then check if this minimum expression can be extended</span></td></tr>
<tr><td class="num" id="LN2065">2065</td><td class="line"> <span class='comment'>* with (set, aff).</span></td></tr>
<tr><td class="num" id="LN2066">2066</td><td class="line"> <span class='comment'>* If so, extend the sequence and return.</span></td></tr>
<tr><td class="num" id="LN2067">2067</td><td class="line"> <span class='comment'>* Perform the same operation for maximum expressions.</span></td></tr>
<tr><td class="num" id="LN2068">2068</td><td class="line"> <span class='comment'>* If no such extension can be performed, then move to the next piece</span></td></tr>
<tr><td class="num" id="LN2069">2069</td><td class="line"> <span class='comment'>* in "data" (if the current piece contains any data), and then store</span></td></tr>
<tr><td class="num" id="LN2070">2070</td><td class="line"> <span class='comment'>* the current subpiece in the current piece of "data" for later handling.</span></td></tr>
<tr><td class="num" id="LN2071">2071</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN2072">2072</td><td class="line"><span class='keyword'>static</span> isl_stat ast_expr_from_pw_aff(<span class='macro'>__isl_take<span class='expansion'>__attribute__((cf_consumed))</span></span> isl_set *set,</td></tr>
<tr><td class="num" id="LN2073">2073</td><td class="line">	<span class='macro'>__isl_take<span class='expansion'>__attribute__((cf_consumed))</span></span> isl_aff *aff, <span class='keyword'>void</span> *user)</td></tr>
<tr><td class="num" id="LN2074">2074</td><td class="line">{</td></tr>
<tr><td class="num" id="LN2075">2075</td><td class="line">	<span class='keyword'>struct</span> isl_from_pw_aff_data *data = user;</td></tr>
<tr><td class="num" id="LN2076">2076</td><td class="line">	isl_bool test;</td></tr>
<tr><td class="num" id="LN2077">2077</td><td class="line">	<span class='keyword'>enum</span> isl_from_pw_aff_state state;</td></tr>
<tr><td class="num" id="LN2078">2078</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2079">2079</td><td class="line">	state = data-&gt;p[data-&gt;n].state;</td></tr>
<tr><td class="num" id="LN2080">2080</td><td class="line">	<span class='keyword'>if</span> (state == isl_state_single) {</td></tr>
<tr><td class="num" id="LN2081">2081</td><td class="line">		isl_aff *aff0;</td></tr>
<tr><td class="num" id="LN2082">2082</td><td class="line">		isl_set *eq;</td></tr>
<tr><td class="num" id="LN2083">2083</td><td class="line">		isl_bool subset1, subset2 = isl_bool_false;</td></tr>
<tr><td class="num" id="LN2084">2084</td><td class="line">		aff0 = isl_aff_list_get_aff(data-&gt;p[data-&gt;n].aff_list, 0);</td></tr>
<tr><td class="num" id="LN2085">2085</td><td class="line">		eq = isl_aff_eq_set(isl_aff_copy(aff), aff0);</td></tr>
<tr><td class="num" id="LN2086">2086</td><td class="line">		subset1 = isl_set_is_subset(set, eq);</td></tr>
<tr><td class="num" id="LN2087">2087</td><td class="line">		<span class='keyword'>if</span> (subset1 &gt;= 0 &amp;&amp; !subset1)</td></tr>
<tr><td class="num" id="LN2088">2088</td><td class="line">			subset2 = single_is_subset(data, eq);</td></tr>
<tr><td class="num" id="LN2089">2089</td><td class="line">		isl_set_free(eq);</td></tr>
<tr><td class="num" id="LN2090">2090</td><td class="line">		<span class='keyword'>if</span> (subset1 &lt; 0 || subset2 &lt; 0)</td></tr>
<tr><td class="num" id="LN2091">2091</td><td class="line">			<span class='keyword'>goto</span> error;</td></tr>
<tr><td class="num" id="LN2092">2092</td><td class="line">		<span class='keyword'>if</span> (subset1)</td></tr>
<tr><td class="num" id="LN2093">2093</td><td class="line">			<span class='keyword'>return</span> extend_domain(data, set, aff, 0);</td></tr>
<tr><td class="num" id="LN2094">2094</td><td class="line">		<span class='keyword'>if</span> (subset2)</td></tr>
<tr><td class="num" id="LN2095">2095</td><td class="line">			<span class='keyword'>return</span> extend_domain(data, set, aff, 1);</td></tr>
<tr><td class="num" id="LN2096">2096</td><td class="line">	}</td></tr>
<tr><td class="num" id="LN2097">2097</td><td class="line">	<span class='keyword'>if</span> (state == isl_state_single || state == isl_state_min) {</td></tr>
<tr><td class="num" id="LN2098">2098</td><td class="line">		test = extends_min(data, set, aff);</td></tr>
<tr><td class="num" id="LN2099">2099</td><td class="line">		<span class='keyword'>if</span> (test &lt; 0)</td></tr>
<tr><td class="num" id="LN2100">2100</td><td class="line">			<span class='keyword'>goto</span> error;</td></tr>
<tr><td class="num" id="LN2101">2101</td><td class="line">		<span class='keyword'>if</span> (test)</td></tr>
<tr><td class="num" id="LN2102">2102</td><td class="line">			<span class='keyword'>return</span> extend_min(data, set, aff);</td></tr>
<tr><td class="num" id="LN2103">2103</td><td class="line">	}</td></tr>
<tr><td class="num" id="LN2104">2104</td><td class="line">	<span class='keyword'>if</span> (state == isl_state_single || state == isl_state_max) {</td></tr>
<tr><td class="num" id="LN2105">2105</td><td class="line">		test = extends_max(data, set, aff);</td></tr>
<tr><td class="num" id="LN2106">2106</td><td class="line">		<span class='keyword'>if</span> (test &lt; 0)</td></tr>
<tr><td class="num" id="LN2107">2107</td><td class="line">			<span class='keyword'>goto</span> error;</td></tr>
<tr><td class="num" id="LN2108">2108</td><td class="line">		<span class='keyword'>if</span> (test)</td></tr>
<tr><td class="num" id="LN2109">2109</td><td class="line">			<span class='keyword'>return</span> extend_max(data, set, aff);</td></tr>
<tr><td class="num" id="LN2110">2110</td><td class="line">	}</td></tr>
<tr><td class="num" id="LN2111">2111</td><td class="line">	<span class='keyword'>if</span> (state != isl_state_none)</td></tr>
<tr><td class="num" id="LN2112">2112</td><td class="line">		data-&gt;n++;</td></tr>
<tr><td class="num" id="LN2113">2113</td><td class="line">	set_single(data, set, aff);</td></tr>
<tr><td class="num" id="LN2114">2114</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2115">2115</td><td class="line">	<span class='keyword'>return</span> isl_stat_ok;</td></tr>
<tr><td class="num" id="LN2116">2116</td><td class="line">error:</td></tr>
<tr><td class="num" id="LN2117">2117</td><td class="line">	isl_set_free(set);</td></tr>
<tr><td class="num" id="LN2118">2118</td><td class="line">	isl_aff_free(aff);</td></tr>
<tr><td class="num" id="LN2119">2119</td><td class="line">	<span class='keyword'>return</span> isl_stat_error;</td></tr>
<tr><td class="num" id="LN2120">2120</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2121">2121</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2122">2122</td><td class="line"><span class='comment'>/* Construct an isl_ast_expr that evaluates "pa".</span></td></tr>
<tr><td class="num" id="LN2123">2123</td><td class="line"> <span class='comment'>* The result is simplified in terms of build-&gt;domain.</span></td></tr>
<tr><td class="num" id="LN2124">2124</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN2125">2125</td><td class="line"> <span class='comment'>* The domain of "pa" lives in the internal schedule space.</span></td></tr>
<tr><td class="num" id="LN2126">2126</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN2127">2127</td><td class="line"><span class='macro'>__isl_give<span class='expansion'>__attribute__((cf_returns_retained))</span></span> isl_ast_expr *isl_ast_build_expr_from_pw_aff_internal(</td></tr>
<tr><td class="num" id="LN2128">2128</td><td class="line">	__isl_keep isl_ast_build *build, <span class='macro'>__isl_take<span class='expansion'>__attribute__((cf_consumed))</span></span> isl_pw_aff *pa)</td></tr>
<tr><td class="num" id="LN2129">2129</td><td class="line">{</td></tr>
<tr><td class="num" id="LN2130">2130</td><td class="line">	<span class='keyword'>struct</span> isl_from_pw_aff_data data = { <span class='macro'>NULL<span class='expansion'>((void*)0)</span></span> };</td></tr>
<tr><td class="num" id="LN2131">2131</td><td class="line">	isl_ast_expr *res = <span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;</td></tr>
<tr><td class="num" id="LN2132">2132</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2133">2133</td><td class="line">	pa = isl_ast_build_compute_gist_pw_aff(build, pa);</td></tr>
<tr><td class="num" id="LN2134">2134</td><td class="line">	pa = isl_pw_aff_coalesce(pa);</td></tr>
<tr><td class="num" id="LN2135">2135</td><td class="line">	<span class='keyword'>if</span> (!pa)</td></tr>
<tr><td class="num" id="LN2136">2136</td><td class="line">		<span class='keyword'>return</span> <span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;</td></tr>
<tr><td class="num" id="LN2137">2137</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2138">2138</td><td class="line">	<span class='keyword'>if</span> (isl_from_pw_aff_data_init(&amp;data, build, pa) &lt; 0)</td></tr>
<tr><td class="num" id="LN2139">2139</td><td class="line">		<span class='keyword'>goto</span> error;</td></tr>
<tr><td class="num" id="LN2140">2140</td><td class="line">	set_none(&amp;data);</td></tr>
<tr><td class="num" id="LN2141">2141</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2142">2142</td><td class="line">	<span class='keyword'>if</span> (isl_pw_aff_foreach_piece(pa, &amp;ast_expr_from_pw_aff, &amp;data) &gt;= 0)</td></tr>
<tr><td class="num" id="LN2143">2143</td><td class="line">		res = build_pieces(&amp;data);</td></tr>
<tr><td class="num" id="LN2144">2144</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2145">2145</td><td class="line">	isl_pw_aff_free(pa);</td></tr>
<tr><td class="num" id="LN2146">2146</td><td class="line">	isl_from_pw_aff_data_clear(&amp;data);</td></tr>
<tr><td class="num" id="LN2147">2147</td><td class="line">	<span class='keyword'>return</span> res;</td></tr>
<tr><td class="num" id="LN2148">2148</td><td class="line">error:</td></tr>
<tr><td class="num" id="LN2149">2149</td><td class="line">	isl_pw_aff_free(pa);</td></tr>
<tr><td class="num" id="LN2150">2150</td><td class="line">	isl_from_pw_aff_data_clear(&amp;data);</td></tr>
<tr><td class="num" id="LN2151">2151</td><td class="line">	<span class='keyword'>return</span> <span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;</td></tr>
<tr><td class="num" id="LN2152">2152</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2153">2153</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2154">2154</td><td class="line"><span class='comment'>/* Construct an isl_ast_expr that evaluates "pa".</span></td></tr>
<tr><td class="num" id="LN2155">2155</td><td class="line"> <span class='comment'>* The result is simplified in terms of build-&gt;domain.</span></td></tr>
<tr><td class="num" id="LN2156">2156</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN2157">2157</td><td class="line"> <span class='comment'>* The domain of "pa" lives in the external schedule space.</span></td></tr>
<tr><td class="num" id="LN2158">2158</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN2159">2159</td><td class="line"><span class='macro'>__isl_give<span class='expansion'>__attribute__((cf_returns_retained))</span></span> isl_ast_expr *isl_ast_build_expr_from_pw_aff(</td></tr>
<tr><td class="num" id="LN2160">2160</td><td class="line">	__isl_keep isl_ast_build *build, <span class='macro'>__isl_take<span class='expansion'>__attribute__((cf_consumed))</span></span> isl_pw_aff *pa)</td></tr>
<tr><td class="num" id="LN2161">2161</td><td class="line">{</td></tr>
<tr><td class="num" id="LN2162">2162</td><td class="line">	isl_ast_expr *expr;</td></tr>
<tr><td class="num" id="LN2163">2163</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2164">2164</td><td class="line">	<span class='keyword'>if</span> (isl_ast_build_need_schedule_map(build)) {</td></tr>
<tr><td class="num" id="LN2165">2165</td><td class="line">		isl_multi_aff *ma;</td></tr>
<tr><td class="num" id="LN2166">2166</td><td class="line">		ma = isl_ast_build_get_schedule_map_multi_aff(build);</td></tr>
<tr><td class="num" id="LN2167">2167</td><td class="line">		pa = isl_pw_aff_pullback_multi_aff(pa, ma);</td></tr>
<tr><td class="num" id="LN2168">2168</td><td class="line">	}</td></tr>
<tr><td class="num" id="LN2169">2169</td><td class="line">	expr = isl_ast_build_expr_from_pw_aff_internal(build, pa);</td></tr>
<tr><td class="num" id="LN2170">2170</td><td class="line">	<span class='keyword'>return</span> expr;</td></tr>
<tr><td class="num" id="LN2171">2171</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2172">2172</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2173">2173</td><td class="line"><span class='comment'>/* Set the ids of the input dimensions of "mpa" to the iterator ids</span></td></tr>
<tr><td class="num" id="LN2174">2174</td><td class="line"> <span class='comment'>* of "build".</span></td></tr>
<tr><td class="num" id="LN2175">2175</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN2176">2176</td><td class="line"> <span class='comment'>* The domain of "mpa" is assumed to live in the internal schedule domain.</span></td></tr>
<tr><td class="num" id="LN2177">2177</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN2178">2178</td><td class="line"><span class='keyword'>static</span> <span class='macro'>__isl_give<span class='expansion'>__attribute__((cf_returns_retained))</span></span> isl_multi_pw_aff *set_iterator_names(</td></tr>
<tr><td class="num" id="LN2179">2179</td><td class="line">	__isl_keep isl_ast_build *build, <span class='macro'>__isl_take<span class='expansion'>__attribute__((cf_consumed))</span></span> isl_multi_pw_aff *mpa)</td></tr>
<tr><td class="num" id="LN2180">2180</td><td class="line">{</td></tr>
<tr><td class="num" id="LN2181">2181</td><td class="line">	<span class='keyword'>int</span> i, n;</td></tr>
<tr><td class="num" id="LN2182">2182</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2183">2183</td><td class="line">	n = isl_multi_pw_aff_dim(mpa, isl_dim_in);</td></tr>
<tr><td class="num" id="LN2184">2184</td><td class="line">	<span class='keyword'>for</span> (i = 0; i &lt; n; ++i) {</td></tr>
<tr><td class="num" id="LN2185">2185</td><td class="line">		isl_id *id;</td></tr>
<tr><td class="num" id="LN2186">2186</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2187">2187</td><td class="line">		id = isl_ast_build_get_iterator_id(build, i);</td></tr>
<tr><td class="num" id="LN2188">2188</td><td class="line">		mpa = isl_multi_pw_aff_set_dim_id(mpa, isl_dim_in, i, id);</td></tr>
<tr><td class="num" id="LN2189">2189</td><td class="line">	}</td></tr>
<tr><td class="num" id="LN2190">2190</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2191">2191</td><td class="line">	<span class='keyword'>return</span> mpa;</td></tr>
<tr><td class="num" id="LN2192">2192</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2193">2193</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2194">2194</td><td class="line"><span class='comment'>/* Construct an isl_ast_expr of type "type" with as first argument "arg0" and</span></td></tr>
<tr><td class="num" id="LN2195">2195</td><td class="line"> <span class='comment'>* the remaining arguments derived from "mpa".</span></td></tr>
<tr><td class="num" id="LN2196">2196</td><td class="line"> <span class='comment'>* That is, construct a call or access expression that calls/accesses "arg0"</span></td></tr>
<tr><td class="num" id="LN2197">2197</td><td class="line"> <span class='comment'>* with arguments/indices specified by "mpa".</span></td></tr>
<tr><td class="num" id="LN2198">2198</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN2199">2199</td><td class="line"><span class='keyword'>static</span> <span class='macro'>__isl_give<span class='expansion'>__attribute__((cf_returns_retained))</span></span> isl_ast_expr *isl_ast_build_with_arguments(</td></tr>
<tr><td class="num" id="LN2200">2200</td><td class="line">	__isl_keep isl_ast_build *build, <span class='keyword'>enum</span> isl_ast_op_type type,</td></tr>
<tr><td class="num" id="LN2201">2201</td><td class="line">	<span class='macro'>__isl_take<span class='expansion'>__attribute__((cf_consumed))</span></span> isl_ast_expr *arg0, <span class='macro'>__isl_take<span class='expansion'>__attribute__((cf_consumed))</span></span> isl_multi_pw_aff *mpa)</td></tr>
<tr><td class="num" id="LN2202">2202</td><td class="line">{</td></tr>
<tr><td class="num" id="LN2203">2203</td><td class="line">	<span class='keyword'>int</span> i, n;</td></tr>
<tr><td class="num" id="LN2204">2204</td><td class="line">	isl_ctx *ctx;</td></tr>
<tr><td class="num" id="LN2205">2205</td><td class="line">	isl_ast_expr *expr;</td></tr>
<tr><td class="num" id="LN2206">2206</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2207">2207</td><td class="line">	ctx = isl_ast_build_get_ctx(build);</td></tr>
<tr><td class="num" id="LN2208">2208</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2209">2209</td><td class="line">	n = isl_multi_pw_aff_dim(mpa, isl_dim_out);</td></tr>
<tr><td class="num" id="LN2210">2210</td><td class="line">	expr = isl_ast_expr_alloc_op(ctx, type, 1 + n);</td></tr>
<tr><td class="num" id="LN2211">2211</td><td class="line">	expr = isl_ast_expr_set_op_arg(expr, 0, arg0);</td></tr>
<tr><td class="num" id="LN2212">2212</td><td class="line">	<span class='keyword'>for</span> (i = 0; i &lt; n; ++i) {</td></tr>
<tr><td class="num" id="LN2213">2213</td><td class="line">		isl_pw_aff *pa;</td></tr>
<tr><td class="num" id="LN2214">2214</td><td class="line">		isl_ast_expr *arg;</td></tr>
<tr><td class="num" id="LN2215">2215</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2216">2216</td><td class="line">		pa = isl_multi_pw_aff_get_pw_aff(mpa, i);</td></tr>
<tr><td class="num" id="LN2217">2217</td><td class="line">		arg = isl_ast_build_expr_from_pw_aff_internal(build, pa);</td></tr>
<tr><td class="num" id="LN2218">2218</td><td class="line">		expr = isl_ast_expr_set_op_arg(expr, 1 + i, arg);</td></tr>
<tr><td class="num" id="LN2219">2219</td><td class="line">	}</td></tr>
<tr><td class="num" id="LN2220">2220</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2221">2221</td><td class="line">	isl_multi_pw_aff_free(mpa);</td></tr>
<tr><td class="num" id="LN2222">2222</td><td class="line">	<span class='keyword'>return</span> expr;</td></tr>
<tr><td class="num" id="LN2223">2223</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2224">2224</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2225">2225</td><td class="line"><span class='keyword'>static</span> <span class='macro'>__isl_give<span class='expansion'>__attribute__((cf_returns_retained))</span></span> isl_ast_expr *isl_ast_build_from_multi_pw_aff_internal(</td></tr>
<tr><td class="num" id="LN2226">2226</td><td class="line">	__isl_keep isl_ast_build *build, <span class='keyword'>enum</span> isl_ast_op_type type,</td></tr>
<tr><td class="num" id="LN2227">2227</td><td class="line">	<span class='macro'>__isl_take<span class='expansion'>__attribute__((cf_consumed))</span></span> isl_multi_pw_aff *mpa);</td></tr>
<tr><td class="num" id="LN2228">2228</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2229">2229</td><td class="line"><span class='comment'>/* Construct an isl_ast_expr that accesses the member specified by "mpa".</span></td></tr>
<tr><td class="num" id="LN2230">2230</td><td class="line"> <span class='comment'>* The range of "mpa" is assumed to be wrapped relation.</span></td></tr>
<tr><td class="num" id="LN2231">2231</td><td class="line"> <span class='comment'>* The domain of this wrapped relation specifies the structure being</span></td></tr>
<tr><td class="num" id="LN2232">2232</td><td class="line"> <span class='comment'>* accessed, while the range of this wrapped relation spacifies the</span></td></tr>
<tr><td class="num" id="LN2233">2233</td><td class="line"> <span class='comment'>* member of the structure being accessed.</span></td></tr>
<tr><td class="num" id="LN2234">2234</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN2235">2235</td><td class="line"> <span class='comment'>* The domain of "mpa" is assumed to live in the internal schedule domain.</span></td></tr>
<tr><td class="num" id="LN2236">2236</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN2237">2237</td><td class="line"><span class='keyword'>static</span> <span class='macro'>__isl_give<span class='expansion'>__attribute__((cf_returns_retained))</span></span> isl_ast_expr *isl_ast_build_from_multi_pw_aff_member(</td></tr>
<tr><td class="num" id="LN2238">2238</td><td class="line">	__isl_keep isl_ast_build *build, <span class='macro'>__isl_take<span class='expansion'>__attribute__((cf_consumed))</span></span> isl_multi_pw_aff *mpa)</td></tr>
<tr><td class="num" id="LN2239">2239</td><td class="line">{</td></tr>
<tr><td class="num" id="LN2240">2240</td><td class="line">	isl_id *id;</td></tr>
<tr><td class="num" id="LN2241">2241</td><td class="line">	isl_multi_pw_aff *domain;</td></tr>
<tr><td class="num" id="LN2242">2242</td><td class="line">	isl_ast_expr *domain_expr, *expr;</td></tr>
<tr><td class="num" id="LN2243">2243</td><td class="line">	<span class='keyword'>enum</span> isl_ast_op_type type = isl_ast_op_access;</td></tr>
<tr><td class="num" id="LN2244">2244</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2245">2245</td><td class="line">	domain = isl_multi_pw_aff_copy(mpa);</td></tr>
<tr><td class="num" id="LN2246">2246</td><td class="line">	domain = isl_multi_pw_aff_range_factor_domain(domain);</td></tr>
<tr><td class="num" id="LN2247">2247</td><td class="line">	domain_expr = isl_ast_build_from_multi_pw_aff_internal(build,</td></tr>
<tr><td class="num" id="LN2248">2248</td><td class="line">								type, domain);</td></tr>
<tr><td class="num" id="LN2249">2249</td><td class="line">	mpa = isl_multi_pw_aff_range_factor_range(mpa);</td></tr>
<tr><td class="num" id="LN2250">2250</td><td class="line">	<span class='keyword'>if</span> (!isl_multi_pw_aff_has_tuple_id(mpa, isl_dim_out))</td></tr>
<tr><td class="num" id="LN2251">2251</td><td class="line">		<span class='macro'>isl_die(isl_ast_build_get_ctx(build), isl_error_invalid,<span class='expansion'>do { isl_handle_error(isl_ast_build_get_ctx(build), isl_error_invalid<br>, "missing field name", "/cluster/home/tgrosser/polly/llvm_git/tools/polly/lib/External/isl/isl_ast_build_expr.c"<br>, 2252); goto error; } while (0)</span></span></td></tr>
<tr><td class="num" id="LN2252">2252</td><td class="line">			<span class='string_literal'><span class='macro'>"missing field name"</span>, <span class='keyword'>goto</span> error)<span class='expansion'>do { isl_handle_error(isl_ast_build_get_ctx(build), isl_error_invalid<br>, "missing field name", "/cluster/home/tgrosser/polly/llvm_git/tools/polly/lib/External/isl/isl_ast_build_expr.c"<br>, 2252); goto error; } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN2253">2253</td><td class="line">	id = isl_multi_pw_aff_get_tuple_id(mpa, isl_dim_out);</td></tr>
<tr><td class="num" id="LN2254">2254</td><td class="line">	expr = isl_ast_expr_from_id(id);</td></tr>
<tr><td class="num" id="LN2255">2255</td><td class="line">	expr = isl_ast_expr_alloc_binary(isl_ast_op_member, domain_expr, expr);</td></tr>
<tr><td class="num" id="LN2256">2256</td><td class="line">	<span class='keyword'>return</span> isl_ast_build_with_arguments(build, type, expr, mpa);</td></tr>
<tr><td class="num" id="LN2257">2257</td><td class="line">error:</td></tr>
<tr><td class="num" id="LN2258">2258</td><td class="line">	isl_multi_pw_aff_free(mpa);</td></tr>
<tr><td class="num" id="LN2259">2259</td><td class="line">	<span class='keyword'>return</span> <span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;</td></tr>
<tr><td class="num" id="LN2260">2260</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2261">2261</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2262">2262</td><td class="line"><span class='comment'>/* Construct an isl_ast_expr of type "type" that calls or accesses</span></td></tr>
<tr><td class="num" id="LN2263">2263</td><td class="line"> <span class='comment'>* the element specified by "mpa".</span></td></tr>
<tr><td class="num" id="LN2264">2264</td><td class="line"> <span class='comment'>* The first argument is obtained from the output tuple name.</span></td></tr>
<tr><td class="num" id="LN2265">2265</td><td class="line"> <span class='comment'>* The remaining arguments are given by the piecewise affine expressions.</span></td></tr>
<tr><td class="num" id="LN2266">2266</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN2267">2267</td><td class="line"> <span class='comment'>* If the range of "mpa" is a mapped relation, then we assume it</span></td></tr>
<tr><td class="num" id="LN2268">2268</td><td class="line"> <span class='comment'>* represents an access to a member of a structure.</span></td></tr>
<tr><td class="num" id="LN2269">2269</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN2270">2270</td><td class="line"> <span class='comment'>* The domain of "mpa" is assumed to live in the internal schedule domain.</span></td></tr>
<tr><td class="num" id="LN2271">2271</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN2272">2272</td><td class="line"><span class='keyword'>static</span> <span class='macro'>__isl_give<span class='expansion'>__attribute__((cf_returns_retained))</span></span> isl_ast_expr *isl_ast_build_from_multi_pw_aff_internal(</td></tr>
<tr><td class="num" id="LN2273">2273</td><td class="line">	__isl_keep isl_ast_build *build, <span class='keyword'>enum</span> isl_ast_op_type type,</td></tr>
<tr><td class="num" id="LN2274">2274</td><td class="line">	<span class='macro'>__isl_take<span class='expansion'>__attribute__((cf_consumed))</span></span> isl_multi_pw_aff *mpa)</td></tr>
<tr><td class="num" id="LN2275">2275</td><td class="line">{</td></tr>
<tr><td class="num" id="LN2276">2276</td><td class="line">	isl_ctx *ctx;</td></tr>
<tr><td class="num" id="LN2277">2277</td><td class="line">	isl_id *id;</td></tr>
<tr><td class="num" id="LN2278">2278</td><td class="line">	isl_ast_expr *expr;</td></tr>
<tr><td class="num" id="LN2279">2279</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2280">2280</td><td class="line">	<span class='keyword'>if</span> (!mpa)</td></tr>
<tr><td class="num" id="LN2281">2281</td><td class="line">		<span class='keyword'>goto</span> error;</td></tr>
<tr><td class="num" id="LN2282">2282</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2283">2283</td><td class="line">	<span class='keyword'>if</span> (type == isl_ast_op_access &amp;&amp;</td></tr>
<tr><td class="num" id="LN2284">2284</td><td class="line">	    isl_multi_pw_aff_range_is_wrapping(mpa))</td></tr>
<tr><td class="num" id="LN2285">2285</td><td class="line">		<span class='keyword'>return</span> isl_ast_build_from_multi_pw_aff_member(build, mpa);</td></tr>
<tr><td class="num" id="LN2286">2286</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2287">2287</td><td class="line">	mpa = set_iterator_names(build, mpa);</td></tr>
<tr><td class="num" id="LN2288">2288</td><td class="line">	<span class='keyword'>if</span> (!build || !mpa)</td></tr>
<tr><td class="num" id="LN2289">2289</td><td class="line">		<span class='keyword'>goto</span> error;</td></tr>
<tr><td class="num" id="LN2290">2290</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2291">2291</td><td class="line">	ctx = isl_ast_build_get_ctx(build);</td></tr>
<tr><td class="num" id="LN2292">2292</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2293">2293</td><td class="line">	<span class='keyword'>if</span> (isl_multi_pw_aff_has_tuple_id(mpa, isl_dim_out))</td></tr>
<tr><td class="num" id="LN2294">2294</td><td class="line">		id = isl_multi_pw_aff_get_tuple_id(mpa, isl_dim_out);</td></tr>
<tr><td class="num" id="LN2295">2295</td><td class="line">	<span class='keyword'>else</span></td></tr>
<tr><td class="num" id="LN2296">2296</td><td class="line">		id = isl_id_alloc(ctx, <span class='string_literal'>""</span>, <span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>);</td></tr>
<tr><td class="num" id="LN2297">2297</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2298">2298</td><td class="line">	expr = isl_ast_expr_from_id(id);</td></tr>
<tr><td class="num" id="LN2299">2299</td><td class="line">	<span class='keyword'>return</span> isl_ast_build_with_arguments(build, type, expr, mpa);</td></tr>
<tr><td class="num" id="LN2300">2300</td><td class="line">error:</td></tr>
<tr><td class="num" id="LN2301">2301</td><td class="line">	isl_multi_pw_aff_free(mpa);</td></tr>
<tr><td class="num" id="LN2302">2302</td><td class="line">	<span class='keyword'>return</span> <span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;</td></tr>
<tr><td class="num" id="LN2303">2303</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2304">2304</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2305">2305</td><td class="line"><span class='comment'>/* Construct an isl_ast_expr of type "type" that calls or accesses</span></td></tr>
<tr><td class="num" id="LN2306">2306</td><td class="line"> <span class='comment'>* the element specified by "pma".</span></td></tr>
<tr><td class="num" id="LN2307">2307</td><td class="line"> <span class='comment'>* The first argument is obtained from the output tuple name.</span></td></tr>
<tr><td class="num" id="LN2308">2308</td><td class="line"> <span class='comment'>* The remaining arguments are given by the piecewise affine expressions.</span></td></tr>
<tr><td class="num" id="LN2309">2309</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN2310">2310</td><td class="line"> <span class='comment'>* The domain of "pma" is assumed to live in the internal schedule domain.</span></td></tr>
<tr><td class="num" id="LN2311">2311</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN2312">2312</td><td class="line"><span class='keyword'>static</span> <span class='macro'>__isl_give<span class='expansion'>__attribute__((cf_returns_retained))</span></span> isl_ast_expr *isl_ast_build_from_pw_multi_aff_internal(</td></tr>
<tr><td class="num" id="LN2313">2313</td><td class="line">	__isl_keep isl_ast_build *build, <span class='keyword'>enum</span> isl_ast_op_type type,</td></tr>
<tr><td class="num" id="LN2314">2314</td><td class="line">	<span class='macro'>__isl_take<span class='expansion'>__attribute__((cf_consumed))</span></span> isl_pw_multi_aff *pma)</td></tr>
<tr><td class="num" id="LN2315">2315</td><td class="line">{</td></tr>
<tr><td class="num" id="LN2316">2316</td><td class="line">	isl_multi_pw_aff *mpa;</td></tr>
<tr><td class="num" id="LN2317">2317</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2318">2318</td><td class="line">	mpa = isl_multi_pw_aff_from_pw_multi_aff(pma);</td></tr>
<tr><td class="num" id="LN2319">2319</td><td class="line">	<span class='keyword'>return</span> isl_ast_build_from_multi_pw_aff_internal(build, type, mpa);</td></tr>
<tr><td class="num" id="LN2320">2320</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2321">2321</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2322">2322</td><td class="line"><span class='comment'>/* Construct an isl_ast_expr of type "type" that calls or accesses</span></td></tr>
<tr><td class="num" id="LN2323">2323</td><td class="line"> <span class='comment'>* the element specified by "mpa".</span></td></tr>
<tr><td class="num" id="LN2324">2324</td><td class="line"> <span class='comment'>* The first argument is obtained from the output tuple name.</span></td></tr>
<tr><td class="num" id="LN2325">2325</td><td class="line"> <span class='comment'>* The remaining arguments are given by the piecewise affine expressions.</span></td></tr>
<tr><td class="num" id="LN2326">2326</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN2327">2327</td><td class="line"> <span class='comment'>* The domain of "mpa" is assumed to live in the external schedule domain.</span></td></tr>
<tr><td class="num" id="LN2328">2328</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN2329">2329</td><td class="line"><span class='keyword'>static</span> <span class='macro'>__isl_give<span class='expansion'>__attribute__((cf_returns_retained))</span></span> isl_ast_expr *isl_ast_build_from_multi_pw_aff(</td></tr>
<tr><td class="num" id="LN2330">2330</td><td class="line">	__isl_keep isl_ast_build *build, <span class='keyword'>enum</span> isl_ast_op_type type,</td></tr>
<tr><td class="num" id="LN2331">2331</td><td class="line">	<span class='macro'>__isl_take<span class='expansion'>__attribute__((cf_consumed))</span></span> isl_multi_pw_aff *mpa)</td></tr>
<tr><td class="num" id="LN2332">2332</td><td class="line">{</td></tr>
<tr><td class="num" id="LN2333">2333</td><td class="line">	<span class='keyword'>int</span> is_domain;</td></tr>
<tr><td class="num" id="LN2334">2334</td><td class="line">	isl_ast_expr *expr;</td></tr>
<tr><td class="num" id="LN2335">2335</td><td class="line">	isl_space *space_build, *space_mpa;</td></tr>
<tr><td class="num" id="LN2336">2336</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2337">2337</td><td class="line">	space_build = isl_ast_build_get_space(build, 0);</td></tr>
<tr><td class="num" id="LN2338">2338</td><td class="line">	space_mpa = isl_multi_pw_aff_get_space(mpa);</td></tr>
<tr><td class="num" id="LN2339">2339</td><td class="line">	is_domain = isl_space_tuple_is_equal(space_build, isl_dim_set,</td></tr>
<tr><td class="num" id="LN2340">2340</td><td class="line">					space_mpa, isl_dim_in);</td></tr>
<tr><td class="num" id="LN2341">2341</td><td class="line">	isl_space_free(space_build);</td></tr>
<tr><td class="num" id="LN2342">2342</td><td class="line">	isl_space_free(space_mpa);</td></tr>
<tr><td class="num" id="LN2343">2343</td><td class="line">	<span class='keyword'>if</span> (is_domain &lt; 0)</td></tr>
<tr><td class="num" id="LN2344">2344</td><td class="line">		<span class='keyword'>goto</span> error;</td></tr>
<tr><td class="num" id="LN2345">2345</td><td class="line">	<span class='keyword'>if</span> (!is_domain)</td></tr>
<tr><td class="num" id="LN2346">2346</td><td class="line">		<span class='macro'>isl_die(isl_ast_build_get_ctx(build), isl_error_invalid,<span class='expansion'>do { isl_handle_error(isl_ast_build_get_ctx(build), isl_error_invalid<br>, "spaces don't match", "/cluster/home/tgrosser/polly/llvm_git/tools/polly/lib/External/isl/isl_ast_build_expr.c"<br>, 2347); goto error; } while (0)</span></span></td></tr>
<tr><td class="num" id="LN2347">2347</td><td class="line">			<span class='string_literal'><span class='macro'>"spaces don't match"</span>, <span class='keyword'>goto</span> error)<span class='expansion'>do { isl_handle_error(isl_ast_build_get_ctx(build), isl_error_invalid<br>, "spaces don't match", "/cluster/home/tgrosser/polly/llvm_git/tools/polly/lib/External/isl/isl_ast_build_expr.c"<br>, 2347); goto error; } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN2348">2348</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2349">2349</td><td class="line">	<span class='keyword'>if</span> (isl_ast_build_need_schedule_map(build)) {</td></tr>
<tr><td class="num" id="LN2350">2350</td><td class="line">		isl_multi_aff *ma;</td></tr>
<tr><td class="num" id="LN2351">2351</td><td class="line">		ma = isl_ast_build_get_schedule_map_multi_aff(build);</td></tr>
<tr><td class="num" id="LN2352">2352</td><td class="line">		mpa = isl_multi_pw_aff_pullback_multi_aff(mpa, ma);</td></tr>
<tr><td class="num" id="LN2353">2353</td><td class="line">	}</td></tr>
<tr><td class="num" id="LN2354">2354</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2355">2355</td><td class="line">	expr = isl_ast_build_from_multi_pw_aff_internal(build, type, mpa);</td></tr>
<tr><td class="num" id="LN2356">2356</td><td class="line">	<span class='keyword'>return</span> expr;</td></tr>
<tr><td class="num" id="LN2357">2357</td><td class="line">error:</td></tr>
<tr><td class="num" id="LN2358">2358</td><td class="line">	isl_multi_pw_aff_free(mpa);</td></tr>
<tr><td class="num" id="LN2359">2359</td><td class="line">	<span class='keyword'>return</span> <span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;</td></tr>
<tr><td class="num" id="LN2360">2360</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2361">2361</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2362">2362</td><td class="line"><span class='comment'>/* Construct an isl_ast_expr that calls the domain element specified by "mpa".</span></td></tr>
<tr><td class="num" id="LN2363">2363</td><td class="line"> <span class='comment'>* The name of the function is obtained from the output tuple name.</span></td></tr>
<tr><td class="num" id="LN2364">2364</td><td class="line"> <span class='comment'>* The arguments are given by the piecewise affine expressions.</span></td></tr>
<tr><td class="num" id="LN2365">2365</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN2366">2366</td><td class="line"> <span class='comment'>* The domain of "mpa" is assumed to live in the external schedule domain.</span></td></tr>
<tr><td class="num" id="LN2367">2367</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN2368">2368</td><td class="line"><span class='macro'>__isl_give<span class='expansion'>__attribute__((cf_returns_retained))</span></span> isl_ast_expr *isl_ast_build_call_from_multi_pw_aff(</td></tr>
<tr><td class="num" id="LN2369">2369</td><td class="line">	__isl_keep isl_ast_build *build, <span class='macro'>__isl_take<span class='expansion'>__attribute__((cf_consumed))</span></span> isl_multi_pw_aff *mpa)</td></tr>
<tr><td class="num" id="LN2370">2370</td><td class="line">{</td></tr>
<tr><td class="num" id="LN2371">2371</td><td class="line">	<span class='keyword'>return</span> isl_ast_build_from_multi_pw_aff(build, isl_ast_op_call, mpa);</td></tr>
<tr><td class="num" id="LN2372">2372</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2373">2373</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2374">2374</td><td class="line"><span class='comment'>/* Construct an isl_ast_expr that accesses the array element specified by "mpa".</span></td></tr>
<tr><td class="num" id="LN2375">2375</td><td class="line"> <span class='comment'>* The name of the array is obtained from the output tuple name.</span></td></tr>
<tr><td class="num" id="LN2376">2376</td><td class="line"> <span class='comment'>* The index expressions are given by the piecewise affine expressions.</span></td></tr>
<tr><td class="num" id="LN2377">2377</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN2378">2378</td><td class="line"> <span class='comment'>* The domain of "mpa" is assumed to live in the external schedule domain.</span></td></tr>
<tr><td class="num" id="LN2379">2379</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN2380">2380</td><td class="line"><span class='macro'>__isl_give<span class='expansion'>__attribute__((cf_returns_retained))</span></span> isl_ast_expr *isl_ast_build_access_from_multi_pw_aff(</td></tr>
<tr><td class="num" id="LN2381">2381</td><td class="line">	__isl_keep isl_ast_build *build, <span class='macro'>__isl_take<span class='expansion'>__attribute__((cf_consumed))</span></span> isl_multi_pw_aff *mpa)</td></tr>
<tr><td class="num" id="LN2382">2382</td><td class="line">{</td></tr>
<tr><td class="num" id="LN2383">2383</td><td class="line">	<span class='keyword'>return</span> isl_ast_build_from_multi_pw_aff(build, isl_ast_op_access, mpa);</td></tr>
<tr><td class="num" id="LN2384">2384</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2385">2385</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2386">2386</td><td class="line"><span class='comment'>/* Construct an isl_ast_expr of type "type" that calls or accesses</span></td></tr>
<tr><td class="num" id="LN2387">2387</td><td class="line"> <span class='comment'>* the element specified by "pma".</span></td></tr>
<tr><td class="num" id="LN2388">2388</td><td class="line"> <span class='comment'>* The first argument is obtained from the output tuple name.</span></td></tr>
<tr><td class="num" id="LN2389">2389</td><td class="line"> <span class='comment'>* The remaining arguments are given by the piecewise affine expressions.</span></td></tr>
<tr><td class="num" id="LN2390">2390</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN2391">2391</td><td class="line"> <span class='comment'>* The domain of "pma" is assumed to live in the external schedule domain.</span></td></tr>
<tr><td class="num" id="LN2392">2392</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN2393">2393</td><td class="line"><span class='keyword'>static</span> <span class='macro'>__isl_give<span class='expansion'>__attribute__((cf_returns_retained))</span></span> isl_ast_expr *isl_ast_build_from_pw_multi_aff(</td></tr>
<tr><td class="num" id="LN2394">2394</td><td class="line">	__isl_keep isl_ast_build *build, <span class='keyword'>enum</span> isl_ast_op_type type,</td></tr>
<tr><td class="num" id="LN2395">2395</td><td class="line">	<span class='macro'>__isl_take<span class='expansion'>__attribute__((cf_consumed))</span></span> isl_pw_multi_aff *pma)</td></tr>
<tr><td class="num" id="LN2396">2396</td><td class="line">{</td></tr>
<tr><td class="num" id="LN2397">2397</td><td class="line">	isl_multi_pw_aff *mpa;</td></tr>
<tr><td class="num" id="LN2398">2398</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2399">2399</td><td class="line">	mpa = isl_multi_pw_aff_from_pw_multi_aff(pma);</td></tr>
<tr><td class="num" id="LN2400">2400</td><td class="line">	<span class='keyword'>return</span> isl_ast_build_from_multi_pw_aff(build, type, mpa);</td></tr>
<tr><td class="num" id="LN2401">2401</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2402">2402</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2403">2403</td><td class="line"><span class='comment'>/* Construct an isl_ast_expr that calls the domain element specified by "pma".</span></td></tr>
<tr><td class="num" id="LN2404">2404</td><td class="line"> <span class='comment'>* The name of the function is obtained from the output tuple name.</span></td></tr>
<tr><td class="num" id="LN2405">2405</td><td class="line"> <span class='comment'>* The arguments are given by the piecewise affine expressions.</span></td></tr>
<tr><td class="num" id="LN2406">2406</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN2407">2407</td><td class="line"> <span class='comment'>* The domain of "pma" is assumed to live in the external schedule domain.</span></td></tr>
<tr><td class="num" id="LN2408">2408</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN2409">2409</td><td class="line"><span class='macro'>__isl_give<span class='expansion'>__attribute__((cf_returns_retained))</span></span> isl_ast_expr *isl_ast_build_call_from_pw_multi_aff(</td></tr>
<tr><td class="num" id="LN2410">2410</td><td class="line">	__isl_keep isl_ast_build *build, <span class='macro'>__isl_take<span class='expansion'>__attribute__((cf_consumed))</span></span> isl_pw_multi_aff *pma)</td></tr>
<tr><td class="num" id="LN2411">2411</td><td class="line">{</td></tr>
<tr><td class="num" id="LN2412">2412</td><td class="line">	<span class='keyword'>return</span> isl_ast_build_from_pw_multi_aff(build, isl_ast_op_call, pma);</td></tr>
<tr><td class="num" id="LN2413">2413</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2414">2414</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2415">2415</td><td class="line"><span class='comment'>/* Construct an isl_ast_expr that accesses the array element specified by "pma".</span></td></tr>
<tr><td class="num" id="LN2416">2416</td><td class="line"> <span class='comment'>* The name of the array is obtained from the output tuple name.</span></td></tr>
<tr><td class="num" id="LN2417">2417</td><td class="line"> <span class='comment'>* The index expressions are given by the piecewise affine expressions.</span></td></tr>
<tr><td class="num" id="LN2418">2418</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN2419">2419</td><td class="line"> <span class='comment'>* The domain of "pma" is assumed to live in the external schedule domain.</span></td></tr>
<tr><td class="num" id="LN2420">2420</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN2421">2421</td><td class="line"><span class='macro'>__isl_give<span class='expansion'>__attribute__((cf_returns_retained))</span></span> isl_ast_expr *isl_ast_build_access_from_pw_multi_aff(</td></tr>
<tr><td class="num" id="LN2422">2422</td><td class="line">	__isl_keep isl_ast_build *build, <span class='macro'>__isl_take<span class='expansion'>__attribute__((cf_consumed))</span></span> isl_pw_multi_aff *pma)</td></tr>
<tr><td class="num" id="LN2423">2423</td><td class="line">{</td></tr>
<tr><td class="num" id="LN2424">2424</td><td class="line">	<span class='keyword'>return</span> isl_ast_build_from_pw_multi_aff(build, isl_ast_op_access, pma);</td></tr>
<tr><td class="num" id="LN2425">2425</td><td class="line">}</td></tr>
<tr><td class="num" id="LN2426">2426</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2427">2427</td><td class="line"><span class='comment'>/* Construct an isl_ast_expr that calls the domain element</span></td></tr>
<tr><td class="num" id="LN2428">2428</td><td class="line"> <span class='comment'>* specified by "executed".</span></td></tr>
<tr><td class="num" id="LN2429">2429</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN2430">2430</td><td class="line"> <span class='comment'>* "executed" is assumed to be single-valued, with a domain that lives</span></td></tr>
<tr><td class="num" id="LN2431">2431</td><td class="line"> <span class='comment'>* in the internal schedule space.</span></td></tr>
<tr><td class="num" id="LN2432">2432</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN2433">2433</td><td class="line"><span class='macro'>__isl_give<span class='expansion'>__attribute__((cf_returns_retained))</span></span> isl_ast_node *isl_ast_build_call_from_executed(</td></tr>
<tr><td class="num" id="LN2434">2434</td><td class="line">	__isl_keep isl_ast_build *build, <span class='macro'>__isl_take<span class='expansion'>__attribute__((cf_consumed))</span></span> isl_map *executed)</td></tr>
<tr><td class="num" id="LN2435">2435</td><td class="line">{</td></tr>
<tr><td class="num" id="LN2436">2436</td><td class="line">	isl_pw_multi_aff *iteration;</td></tr>
<tr><td class="num" id="LN2437">2437</td><td class="line">	isl_ast_expr *expr;</td></tr>
<tr><td class="num" id="LN2438">2438</td><td class="line"> </td></tr>
<tr><td class="num" id="LN2439">2439</td><td class="line">	iteration = isl_pw_multi_aff_from_map(executed);</td></tr>
<tr><td class="num" id="LN2440">2440</td><td class="line">	iteration = isl_ast_build_compute_gist_pw_multi_aff(build, iteration);</td></tr>
<tr><td class="num" id="LN2441">2441</td><td class="line">	iteration = isl_pw_multi_aff_intersect_domain(iteration,</td></tr>
<tr><td class="num" id="LN2442">2442</td><td class="line">					isl_ast_build_get_domain(build));</td></tr>
<tr><td class="num" id="LN2443">2443</td><td class="line">	expr = isl_ast_build_from_pw_multi_aff_internal(build, isl_ast_op_call,</td></tr>
<tr><td class="num" id="LN2444">2444</td><td class="line">							iteration);</td></tr>
<tr><td class="num" id="LN2445">2445</td><td class="line">	<span class='keyword'>return</span> isl_ast_node_alloc_user(expr);</td></tr>
<tr><td class="num" id="LN2446">2446</td><td class="line">}</td></tr>
</table></body></html>
